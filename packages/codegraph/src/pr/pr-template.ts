/**
 * @nahisaho/musubix-codegraph - PR Template Generator
 *
 * Generates PR body content from refactoring suggestions
 *
 * @packageDocumentation
 * @module @nahisaho/musubix-codegraph/pr
 *
 * @see REQ-CG-PR-006 - PR Body Generation
 * @see DES-CG-PR-006 - PR Body Template
 */

import type {
  RefactoringSuggestion,
  FileDiff,
  CodeChange,
  RefactoringType,
  RefactoringSeverity,
} from './types.js';

/**
 * PR Template options
 */
export interface PRTemplateOptions {
  /** Include file diffs in PR body */
  includeDiffs?: boolean;
  /** Maximum diff lines to include (default: 50) */
  maxDiffLines?: number;
  /** Include checklist */
  includeChecklist?: boolean;
  /** Custom checklist items */
  checklistItems?: string[];
  /** Include related issues section */
  includeRelatedIssues?: boolean;
  /** Related issue numbers */
  relatedIssues?: number[];
  /** Custom footer text */
  footer?: string;
}

/**
 * Severity emoji mapping
 */
const SEVERITY_EMOJI: Record<RefactoringSeverity, string> = {
  critical: 'üî¥',
  high: 'üü†',
  medium: 'üü°',
  low: 'üü¢',
  info: 'üîµ',
};

/**
 * Refactoring type labels
 */
const TYPE_LABELS: Record<RefactoringType, string> = {
  extract_interface: 'Interface Extraction',
  extract_method: 'Method Extraction',
  extract_class: 'Class Extraction',
  inline: 'Inline Refactoring',
  rename: 'Rename',
  move: 'Move',
  security_fix: 'Security Fix',
  performance: 'Performance Improvement',
  simplify: 'Code Simplification',
};

/**
 * PR Template Generator
 *
 * Generates well-formatted PR bodies from refactoring suggestions.
 *
 * @see DES-CG-PR-006
 * @example
 * ```typescript
 * const generator = new PRTemplateGenerator();
 * const body = generator.generate(suggestion, diffs);
 * ```
 */
export class PRTemplateGenerator {
  private readonly options: PRTemplateOptions;

  /**
   * Create a new PRTemplateGenerator
   * @param options - Template options
   */
  constructor(options: PRTemplateOptions = {}) {
    this.options = {
      includeDiffs: options.includeDiffs ?? true,
      maxDiffLines: options.maxDiffLines ?? 50,
      includeChecklist: options.includeChecklist ?? true,
      checklistItems: options.checklistItems,
      includeRelatedIssues: options.includeRelatedIssues ?? false,
      relatedIssues: options.relatedIssues ?? [],
      footer: options.footer,
    };
  }

  /**
   * Generate PR body
   * @see REQ-CG-PR-006
   */
  generate(suggestion: RefactoringSuggestion, diffs?: FileDiff[]): string {
    const sections: string[] = [];

    // Header
    sections.push(this.generateHeader(suggestion));

    // Summary
    sections.push(this.generateSummary(suggestion));

    // Changes
    sections.push(this.generateChangesSection(suggestion));

    // Diffs
    if (this.options.includeDiffs && diffs && diffs.length > 0) {
      sections.push(this.generateDiffsSection(diffs));
    }

    // Impact Analysis
    sections.push(this.generateImpactSection(suggestion));

    // Checklist
    if (this.options.includeChecklist) {
      sections.push(this.generateChecklist(suggestion));
    }

    // Related Issues
    if (this.options.includeRelatedIssues && this.options.relatedIssues && this.options.relatedIssues.length > 0) {
      sections.push(this.generateRelatedIssues());
    }

    // Footer
    sections.push(this.generateFooter(suggestion));

    return sections.filter(s => s.length > 0).join('\n\n');
  }

  /**
   * Generate PR title
   */
  generateTitle(suggestion: RefactoringSuggestion): string {
    const typeLabel = TYPE_LABELS[suggestion.type] || suggestion.type;
    return `${typeLabel}: ${suggestion.title}`;
  }

  // ============================================================================
  // Section Generators
  // ============================================================================

  /**
   * Generate header section
   */
  private generateHeader(suggestion: RefactoringSuggestion): string {
    const severity = SEVERITY_EMOJI[suggestion.severity];
    const typeLabel = TYPE_LABELS[suggestion.type] || suggestion.type;

    return `## ${severity} ${typeLabel}

> ü§ñ This PR was automatically generated by **MUSUBIX CodeGraph v2.3.3**`;
  }

  /**
   * Generate summary section
   */
  private generateSummary(suggestion: RefactoringSuggestion): string {
    const lines: string[] = ['### Summary', ''];
    lines.push(suggestion.description);
    lines.push('');
    lines.push(`**Target Entity:** \`${suggestion.entityId}\``);
    lines.push(`**Confidence:** ${Math.round(suggestion.confidence * 100)}%`);

    if (suggestion.cwe) {
      lines.push(`**Security Reference:** [${suggestion.cwe}](https://cwe.mitre.org/data/definitions/${suggestion.cwe.replace('CWE-', '')}.html)`);
    }

    return lines.join('\n');
  }

  /**
   * Generate reason section
   */
  private generateChangesSection(suggestion: RefactoringSuggestion): string {
    const lines: string[] = ['### Reason for Change', ''];
    lines.push(suggestion.reason);
    lines.push('');
    lines.push('### Files Changed');
    lines.push('');

    // Group by file
    const fileChanges = new Map<string, CodeChange[]>();
    for (const change of suggestion.changes) {
      const existing = fileChanges.get(change.filePath) ?? [];
      existing.push(change);
      fileChanges.set(change.filePath, existing);
    }

    for (const [filePath, changes] of fileChanges) {
      lines.push(`- \`${filePath}\``);
      for (const change of changes) {
        lines.push(`  - Lines ${change.startLine}-${change.endLine}: ${change.description}`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Generate diffs section
   */
  private generateDiffsSection(diffs: FileDiff[]): string {
    const lines: string[] = ['### Code Changes', ''];

    for (const diff of diffs) {
      const icon = diff.changeType === 'added' ? '‚ûï' :
                   diff.changeType === 'deleted' ? '‚ûñ' : 'üìù';
      lines.push(`<details>`);
      lines.push(`<summary>${icon} <code>${diff.filePath}</code> (+${diff.additions}/-${diff.deletions})</summary>`);
      lines.push('');

      // Truncate long diffs
      const diffLines = diff.diff.split('\n');
      if (diffLines.length > this.options.maxDiffLines!) {
        const truncated = diffLines.slice(0, this.options.maxDiffLines!).join('\n');
        lines.push('```diff');
        lines.push(truncated);
        lines.push(`... (${diffLines.length - this.options.maxDiffLines!} more lines)`);
        lines.push('```');
      } else {
        lines.push('```diff');
        lines.push(diff.diff);
        lines.push('```');
      }

      lines.push('</details>');
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate impact analysis section
   */
  private generateImpactSection(suggestion: RefactoringSuggestion): string {
    const lines: string[] = ['### Impact Analysis', ''];
    lines.push(`| Metric | Value |`);
    lines.push(`|--------|-------|`);
    lines.push(`| Files Affected | ${suggestion.impact.filesAffected} |`);
    lines.push(`| Lines Changed | ${suggestion.impact.linesChanged} |`);
    lines.push(`| Dependencies | ${suggestion.impact.dependencies.length} |`);

    if (suggestion.impact.dependencies.length > 0) {
      lines.push('');
      lines.push('**Affected Dependencies:**');
      for (const dep of suggestion.impact.dependencies.slice(0, 10)) {
        lines.push(`- \`${dep}\``);
      }
      if (suggestion.impact.dependencies.length > 10) {
        lines.push(`- ... and ${suggestion.impact.dependencies.length - 10} more`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Generate checklist section
   */
  private generateChecklist(suggestion: RefactoringSuggestion): string {
    const lines: string[] = ['### Checklist', ''];

    const defaultItems = [
      'Code compiles without errors',
      'All existing tests pass',
      'New tests added for changed functionality',
      'Documentation updated if necessary',
      'No breaking changes introduced',
    ];

    // Add security-specific items
    if (suggestion.type === 'security_fix') {
      defaultItems.push('Security vulnerability is fully addressed');
      defaultItems.push('No new security issues introduced');
    }

    const items = this.options.checklistItems ?? defaultItems;

    for (const item of items) {
      lines.push(`- [ ] ${item}`);
    }

    return lines.join('\n');
  }

  /**
   * Generate related issues section
   */
  private generateRelatedIssues(): string {
    const lines: string[] = ['### Related Issues', ''];

    for (const issue of this.options.relatedIssues!) {
      lines.push(`- Closes #${issue}`);
    }

    return lines.join('\n');
  }

  /**
   * Generate footer section
   */
  private generateFooter(suggestion: RefactoringSuggestion): string {
    const lines: string[] = ['---', ''];

    if (this.options.footer) {
      lines.push(this.options.footer);
      lines.push('');
    }

    lines.push(`üìã **Suggestion ID:** \`${suggestion.id}\``);
    lines.push(`üïê **Generated:** ${new Date().toISOString()}`);
    lines.push(`üîß **Tool:** MUSUBIX CodeGraph v2.3.3`);

    return lines.join('\n');
  }
}

/**
 * Create a PR template generator
 */
export function createPRTemplateGenerator(options?: PRTemplateOptions): PRTemplateGenerator {
  return new PRTemplateGenerator(options);
}

/**
 * Generate a simple PR body without advanced options
 */
export function generateSimplePRBody(suggestion: RefactoringSuggestion): string {
  const generator = new PRTemplateGenerator({ includeDiffs: false });
  return generator.generate(suggestion);
}

/**
 * Generate PR title from suggestion
 */
export function generatePRTitle(suggestion: RefactoringSuggestion): string {
  const generator = new PRTemplateGenerator();
  return generator.generateTitle(suggestion);
}
