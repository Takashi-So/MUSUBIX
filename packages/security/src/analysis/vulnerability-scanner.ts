/**
 * @fileoverview Vulnerability scanner - static analysis for security vulnerabilities
 * @module @nahisaho/musubix-security/analysis/vulnerability-scanner
 * @trace REQ-SEC-SCAN-001, REQ-SEC-SCAN-002, REQ-SEC-SCAN-003
 */

import type { SourceFile } from 'ts-morph';
import { SyntaxKind } from 'ts-morph';
import type {
  Vulnerability,
  ScanOptions,
  ScanResult,
} from '../types/index.js';
import { ASTParser, getASTParser } from '../infrastructure/ast-parser.js';
import { FileScanner, createFileScanner } from '../infrastructure/file-scanner.js';

/**
 * Vulnerability detector interface
 */
interface VulnerabilityDetector {
  ruleId: string;
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[];
}

/**
 * Generate vulnerability ID
 */
let vulnCounter = 0;
function generateVulnId(): string {
  const date = new Date();
  const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
  return `VULN-${dateStr}-${String(++vulnCounter).padStart(3, '0')}`;
}

/**
 * Reset vulnerability counter (for testing)
 */
export function resetVulnCounter(): void {
  vulnCounter = 0;
}

/**
 * SQL Injection detector
 * @trace REQ-SEC-SCAN-002
 */
const sqlInjectionDetector: VulnerabilityDetector = {
  ruleId: 'SEC-001',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const sqlMethods = ['query', 'execute', 'raw', 'exec'];

      if (funcName && sqlMethods.includes(funcName)) {
        const args = call.getArguments();
        if (args.length > 0) {
          const firstArg = args[0];

          // Check for template literal (potential string concatenation)
          if (firstArg.getKind() === SyntaxKind.TemplateExpression) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'injection',
              severity: 'critical',
              cwes: ['CWE-89'],
              owasp: ['A03:2021'],
              location: parser.getLocation(call),
              description: 'Potential SQL injection: Template literal used in SQL query',
              recommendation: 'Use parameterized queries instead of string interpolation',
              confidence: 0.85,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }

          // Check for binary expression (string concatenation)
          if (firstArg.getKind() === SyntaxKind.BinaryExpression) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'injection',
              severity: 'critical',
              cwes: ['CWE-89'],
              owasp: ['A03:2021'],
              location: parser.getLocation(call),
              description: 'Potential SQL injection: String concatenation in SQL query',
              recommendation: 'Use parameterized queries instead of string concatenation',
              confidence: 0.9,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * Command injection detector
 */
const commandInjectionDetector: VulnerabilityDetector = {
  ruleId: 'SEC-002',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const cmdMethods = ['exec', 'execSync', 'spawn', 'spawnSync', 'execFile'];

      if (funcName && cmdMethods.includes(funcName)) {
        const args = call.getArguments();
        if (args.length > 0) {
          const firstArg = args[0];

          // Check for template literal or binary expression
          if (
            firstArg.getKind() === SyntaxKind.TemplateExpression ||
            firstArg.getKind() === SyntaxKind.BinaryExpression
          ) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'command-injection',
              severity: 'critical',
              cwes: ['CWE-78'],
              owasp: ['A03:2021'],
              location: parser.getLocation(call),
              description: 'Potential command injection: Unsafe command construction',
              recommendation: 'Use execFile with array arguments or properly escape shell arguments',
              confidence: 0.85,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * Path traversal detector
 */
const pathTraversalDetector: VulnerabilityDetector = {
  ruleId: 'SEC-003',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const fsMethods = [
        'readFile', 'readFileSync', 'writeFile', 'writeFileSync',
        'readdir', 'readdirSync', 'unlink', 'unlinkSync',
        'stat', 'statSync', 'access', 'accessSync',
      ];

      if (funcName && fsMethods.includes(funcName)) {
        const args = call.getArguments();
        if (args.length > 0) {
          const firstArg = args[0];

          // Check for template literal or binary expression
          if (
            firstArg.getKind() === SyntaxKind.TemplateExpression ||
            firstArg.getKind() === SyntaxKind.BinaryExpression
          ) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'path-traversal',
              severity: 'high',
              cwes: ['CWE-22'],
              owasp: ['A01:2021'],
              location: parser.getLocation(call),
              description: 'Potential path traversal: User input may be used in file path',
              recommendation: 'Validate and sanitize file paths, use path.resolve() with base directory check',
              confidence: 0.75,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * XSS detector
 */
const xssDetector: VulnerabilityDetector = {
  ruleId: 'SEC-004',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const receiverName = parser.getReceiverName(call);

      // Check res.send(), res.write(), res.end() with template literals
      if (
        receiverName === 'res' &&
        funcName &&
        ['send', 'write', 'end', 'render'].includes(funcName)
      ) {
        const args = call.getArguments();
        if (args.length > 0) {
          const firstArg = args[0];
          if (firstArg.getKind() === SyntaxKind.TemplateExpression) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'xss',
              severity: 'high',
              cwes: ['CWE-79'],
              owasp: ['A03:2021'],
              location: parser.getLocation(call),
              description: 'Potential XSS: Unescaped output to response',
              recommendation: 'Use HTML escaping or a template engine with auto-escaping',
              confidence: 0.7,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }

      // Check innerHTML assignment (requires property access analysis)
      const expr = call.getExpression();
      if (expr.getText().includes('innerHTML')) {
        vulnerabilities.push({
          id: generateVulnId(),
          type: 'xss',
          severity: 'high',
          cwes: ['CWE-79'],
          owasp: ['A03:2021'],
          location: parser.getLocation(call),
          description: 'Potential XSS: innerHTML assignment detected',
          recommendation: 'Use textContent or properly sanitize HTML content',
          confidence: 0.8,
          ruleId: this.ruleId,
          codeSnippet: parser.extractSnippet(call),
          detectedAt: new Date(),
        });
      }
    }

    return vulnerabilities;
  },
};

/**
 * Eval detector
 */
const evalDetector: VulnerabilityDetector = {
  ruleId: 'SEC-005',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);

      if (funcName === 'eval' || funcName === 'Function') {
        vulnerabilities.push({
          id: generateVulnId(),
          type: 'code-injection',
          severity: 'critical',
          cwes: ['CWE-94', 'CWE-95'],
          owasp: ['A03:2021'],
          location: parser.getLocation(call),
          description: `Potential code injection: ${funcName}() usage detected`,
          recommendation: 'Avoid eval() and new Function(). Use safer alternatives.',
          confidence: 0.95,
          ruleId: this.ruleId,
          codeSnippet: parser.extractSnippet(call),
          detectedAt: new Date(),
        });
      }
    }

    return vulnerabilities;
  },
};

/**
 * Prototype pollution detector
 */
const prototypePollutionDetector: VulnerabilityDetector = {
  ruleId: 'SEC-006',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);

      // Object.assign with user input
      if (funcName === 'assign') {
        const receiverName = parser.getReceiverName(call);
        if (receiverName === 'Object') {
          // Check if first argument is Object.prototype or {}
          vulnerabilities.push({
            id: generateVulnId(),
            type: 'prototype-pollution',
            severity: 'high',
            cwes: ['CWE-1321'],
            owasp: ['A08:2021'],
            location: parser.getLocation(call),
            description: 'Potential prototype pollution: Object.assign() with external input',
            recommendation: 'Validate object keys, use Map instead, or freeze prototype',
            confidence: 0.6,
            ruleId: this.ruleId,
            codeSnippet: parser.extractSnippet(call),
            detectedAt: new Date(),
          });
        }
      }
    }

    // Check for __proto__ access
    const propertyAccess = sourceFile.getDescendantsOfKind(SyntaxKind.PropertyAccessExpression);
    for (const access of propertyAccess) {
      if (access.getName() === '__proto__') {
        vulnerabilities.push({
          id: generateVulnId(),
          type: 'prototype-pollution',
          severity: 'high',
          cwes: ['CWE-1321'],
          owasp: ['A08:2021'],
          location: parser.getLocation(access),
          description: 'Potential prototype pollution: __proto__ access detected',
          recommendation: 'Avoid __proto__ access, use Object.getPrototypeOf() if needed',
          confidence: 0.85,
          ruleId: this.ruleId,
          codeSnippet: parser.extractSnippet(access),
          detectedAt: new Date(),
        });
      }
    }

    return vulnerabilities;
  },
};

/**
 * SSRF (Server-Side Request Forgery) detector
 * @trace CWE-918
 */
const ssrfDetector: VulnerabilityDetector = {
  ruleId: 'SEC-007',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    // HTTP client methods that could be vulnerable to SSRF
    const httpMethods = [
      'fetch', 'get', 'post', 'put', 'delete', 'patch', 'request',
      'axios', 'got', 'superagent', 'needle', 'urllib',
    ];
    const httpReceivers = ['axios', 'got', 'request', 'http', 'https', 'fetch', 'node-fetch'];

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const receiverName = parser.getReceiverName(call);

      const isHttpCall = 
        (funcName && httpMethods.includes(funcName)) ||
        (receiverName && httpReceivers.includes(receiverName));

      if (isHttpCall) {
        const args = call.getArguments();
        if (args.length > 0) {
          const firstArg = args[0];
          
          // Check for template literal or binary expression (dynamic URL)
          if (
            firstArg.getKind() === SyntaxKind.TemplateExpression ||
            firstArg.getKind() === SyntaxKind.BinaryExpression ||
            firstArg.getKind() === SyntaxKind.Identifier
          ) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'ssrf',
              severity: 'high',
              cwes: ['CWE-918'],
              owasp: ['A10:2021'],
              location: parser.getLocation(call),
              description: 'Potential SSRF: URL may be constructed from user input',
              recommendation: 'Validate and whitelist allowed URLs/domains. Use URL parsing to verify host.',
              confidence: 0.75,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * Insecure Deserialization detector
 * @trace CWE-502
 */
const insecureDeserializationDetector: VulnerabilityDetector = {
  ruleId: 'SEC-008',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    // Dangerous deserialization functions
    const dangerousFunctions = [
      { func: 'parse', receiver: 'JSON', severity: 'medium' as const, confidence: 0.5 },
      { func: 'unserialize', receiver: null, severity: 'critical' as const, confidence: 0.95 },
      { func: 'deserialize', receiver: null, severity: 'high' as const, confidence: 0.85 },
      { func: 'decode', receiver: 'js-yaml', severity: 'critical' as const, confidence: 0.9 },
      { func: 'load', receiver: 'js-yaml', severity: 'critical' as const, confidence: 0.9 },
      { func: 'load', receiver: 'yaml', severity: 'critical' as const, confidence: 0.9 },
      { func: 'load', receiver: null, severity: 'high' as const, confidence: 0.7 }, // Generic load
      { func: 'safeLoad', receiver: 'js-yaml', severity: 'medium' as const, confidence: 0.6 },
      { func: 'safeLoad', receiver: 'yaml', severity: 'medium' as const, confidence: 0.6 },
      { func: 'parse', receiver: 'yaml', severity: 'high' as const, confidence: 0.85 },
      { func: 'loadAll', receiver: 'js-yaml', severity: 'critical' as const, confidence: 0.9 },
      { func: 'loadAll', receiver: 'yaml', severity: 'critical' as const, confidence: 0.9 },
      { func: 'evalJson', receiver: null, severity: 'critical' as const, confidence: 0.95 },
      { func: 'decodeFromBase64', receiver: null, severity: 'medium' as const, confidence: 0.6 },
    ];

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const receiverName = parser.getReceiverName(call);

      for (const dangerous of dangerousFunctions) {
        if (funcName === dangerous.func) {
          // Check if receiver matches (if specified)
          if (dangerous.receiver && receiverName !== dangerous.receiver) {
            continue;
          }

          const args = call.getArguments();
          if (args.length > 0) {
            const firstArg = args[0];
            
            // Check if input is from user-controlled source
            if (
              firstArg.getKind() === SyntaxKind.Identifier ||
              firstArg.getKind() === SyntaxKind.PropertyAccessExpression ||
              firstArg.getKind() === SyntaxKind.CallExpression
            ) {
              vulnerabilities.push({
                id: generateVulnId(),
                type: 'insecure-deserialization',
                severity: dangerous.severity,
                cwes: ['CWE-502'],
                owasp: ['A08:2021'],
                location: parser.getLocation(call),
                description: `Potential insecure deserialization: ${funcName}() with potentially untrusted input`,
                recommendation: 'Validate input before deserialization. Use safe alternatives like JSON.parse with schema validation.',
                confidence: dangerous.confidence,
                ruleId: this.ruleId,
                codeSnippet: parser.extractSnippet(call),
                detectedAt: new Date(),
              });
            }
          }
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * XXE (XML External Entity) detector
 * @trace CWE-611
 */
const xxeDetector: VulnerabilityDetector = {
  ruleId: 'SEC-009',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    // XML parsing functions
    const xmlParsers = [
      { func: 'parseString', lib: 'xml2js', severity: 'high' as const },
      { func: 'parseStringPromise', lib: 'xml2js', severity: 'high' as const },
      { func: 'parse', lib: 'fast-xml-parser', severity: 'medium' as const },
      { func: 'parseXml', lib: null, severity: 'high' as const },
      { func: 'parseFromString', lib: 'DOMParser', severity: 'high' as const },
      { func: 'load', lib: 'libxmljs', severity: 'critical' as const },
      { func: 'parseXmlString', lib: 'libxmljs', severity: 'critical' as const },
    ];

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      // receiverName could be used for more specific library detection in future
      // const receiverName = parser.getReceiverName(call);

      for (const xmlParser of xmlParsers) {
        if (funcName === xmlParser.func) {
          // Check if options disable external entities
          const args = call.getArguments();
          let hasSecureOptions = false;

          // Look for options argument with security settings
          for (const arg of args) {
            const argText = arg.getText();
            if (
              argText.includes('noent: false') ||
              argText.includes('external: false') ||
              argText.includes('dtd: false') ||
              argText.includes('allowDtd: false') ||
              argText.includes('processEntities: false')
            ) {
              hasSecureOptions = true;
              break;
            }
          }

          if (!hasSecureOptions) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'xxe',
              severity: xmlParser.severity,
              cwes: ['CWE-611'],
              owasp: ['A05:2021'],
              location: parser.getLocation(call),
              description: `Potential XXE vulnerability: ${funcName}() may process external entities`,
              recommendation: 'Disable external entity processing. Set noent: false, external: false in parser options.',
              confidence: 0.7,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }
    }

    // Check for dangerous XML parser configurations
    const newExpressions = sourceFile.getDescendantsOfKind(SyntaxKind.NewExpression);
    for (const newExpr of newExpressions) {
      const className = newExpr.getExpression().getText();
      if (className === 'DOMParser' || className === 'XMLSerializer') {
        vulnerabilities.push({
          id: generateVulnId(),
          type: 'xxe',
          severity: 'medium',
          cwes: ['CWE-611'],
          owasp: ['A05:2021'],
          location: parser.getLocation(newExpr),
          description: `XML parser instantiation detected: ${className} - verify XXE protections`,
          recommendation: 'Ensure XML parser is configured to disable external entities and DTD processing.',
          confidence: 0.5,
          ruleId: this.ruleId,
          codeSnippet: parser.extractSnippet(newExpr),
          detectedAt: new Date(),
        });
      }
    }

    return vulnerabilities;
  },
};

/**
 * LDAP Injection detector
 * @trace CWE-90
 */
const ldapInjectionDetector: VulnerabilityDetector = {
  ruleId: 'SEC-010',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    // LDAP operations
    const ldapMethods = [
      'search', 'bind', 'add', 'modify', 'del', 'compare',
      'modifyDN', 'exop', 'searchAsync', 'bindAsync',
    ];
    const ldapReceivers = ['ldap', 'ldapjs', 'client', 'ldapClient', 'activedirectory'];

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const receiverName = parser.getReceiverName(call);

      const isLdapCall = 
        (funcName && ldapMethods.includes(funcName)) &&
        (receiverName && ldapReceivers.some(r => receiverName.toLowerCase().includes(r)));

      if (isLdapCall || (funcName && funcName.toLowerCase().includes('ldap'))) {
        const args = call.getArguments();
        
        for (const arg of args) {
          // Check for dynamic filter construction
          if (
            arg.getKind() === SyntaxKind.TemplateExpression ||
            arg.getKind() === SyntaxKind.BinaryExpression
          ) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'ldap-injection',
              severity: 'critical',
              cwes: ['CWE-90'],
              owasp: ['A03:2021'],
              location: parser.getLocation(call),
              description: 'Potential LDAP injection: Dynamic LDAP filter construction detected',
              recommendation: 'Use parameterized LDAP queries. Escape special characters (*, (, ), \\, NUL).',
              confidence: 0.85,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
            break;
          }
        }
      }
    }

    // Check for LDAP filter string patterns
    const stringLiterals = sourceFile.getDescendantsOfKind(SyntaxKind.StringLiteral);
    for (const literal of stringLiterals) {
      const text = literal.getText();
      // Check for LDAP filter patterns like (&(uid=...) or (|(cn=...)
      if (text.match(/\(\s*[&|]\s*\([a-zA-Z]+=/)) {
        const parent = literal.getParent();
        if (parent && parent.getKind() === SyntaxKind.BinaryExpression) {
          vulnerabilities.push({
            id: generateVulnId(),
            type: 'ldap-injection',
            severity: 'high',
            cwes: ['CWE-90'],
            owasp: ['A03:2021'],
            location: parser.getLocation(literal),
            description: 'Potential LDAP injection: LDAP filter with string concatenation',
            recommendation: 'Use LDAP filter escaping function or parameterized queries.',
            confidence: 0.8,
            ruleId: this.ruleId,
            codeSnippet: parser.extractSnippet(parent),
            detectedAt: new Date(),
          });
        }
      }
    }

    // Check template literals for LDAP filter patterns
    const templateExpressions = sourceFile.getDescendantsOfKind(SyntaxKind.TemplateExpression);
    for (const template of templateExpressions) {
      const text = template.getText();
      // Check for LDAP filter patterns in template literals
      if (text.match(/\(\s*[&|]\s*\([a-zA-Z]+=/) || 
          text.match(/\(\s*[a-zA-Z]+=\s*\$\{/) ||
          text.match(/objectClass|uid=|cn=|dn=|ou=/i)) {
        vulnerabilities.push({
          id: generateVulnId(),
          type: 'ldap-injection',
          severity: 'critical',
          cwes: ['CWE-90'],
          owasp: ['A03:2021'],
          location: parser.getLocation(template),
          description: 'Potential LDAP injection: Template literal used in LDAP filter',
          recommendation: 'Use LDAP filter escaping function. Never interpolate user input directly into LDAP filters.',
          confidence: 0.85,
          ruleId: this.ruleId,
          codeSnippet: parser.extractSnippet(template),
          detectedAt: new Date(),
        });
      }
    }

    return vulnerabilities;
  },
};

/**
 * ReDoS (Regular Expression Denial of Service) detector
 * @trace CWE-1333
 */
const redosDetector: VulnerabilityDetector = {
  ruleId: 'SEC-011',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Patterns known to cause catastrophic backtracking
    const dangerousPatterns = [
      { pattern: /\(\.\*\)\+/, description: '(.*)+' },
      { pattern: /\(\.\+\)\+/, description: '(.+)+' },
      { pattern: /\([^)]*\+\)\+/, description: '(a+)+' },
      { pattern: /\([^)]*\*\)\+/, description: '(a*)+' },
      { pattern: /\([^)]*\+\)\*/, description: '(a+)*' },
      { pattern: /\([^)]*\*\)\*/, description: '(a*)*' },
      { pattern: /\(\.\*\)\*/, description: '(.*)*' },
      { pattern: /\(\.\+\)\*/, description: '(.+)*' },
      { pattern: /\(\[.*?\]\+\)\+/, description: '([a-z]+)+' },
      { pattern: /\\s\*\\S\*\\s\*/, description: '\\s*\\S*\\s*' },
      { pattern: /\(\.\*\?\)\{/, description: '(.*?){n}' },
    ];

    // Check RegExp constructor calls
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);
    const newExpressions = sourceFile.getDescendantsOfKind(SyntaxKind.NewExpression);

    const checkRegexArg = (arg: any, location: any) => {
      const argText = arg.getText();
      
      for (const dangerous of dangerousPatterns) {
        if (dangerous.pattern.test(argText)) {
          vulnerabilities.push({
            id: generateVulnId(),
            type: 'redos',
            severity: 'high',
            cwes: ['CWE-1333'],
            owasp: ['A06:2021'],
            location: parser.getLocation(location),
            description: `Potential ReDoS: Pattern "${dangerous.description}" can cause catastrophic backtracking`,
            recommendation: 'Use atomic groups, possessive quantifiers, or rewrite the regex. Consider using RE2 for untrusted input.',
            confidence: 0.85,
            ruleId: this.ruleId,
            codeSnippet: parser.extractSnippet(location),
            detectedAt: new Date(),
          });
        }
      }

      // Check for nested quantifiers
      if (argText.match(/\([^)]*[+*][^)]*\)[+*]/)) {
        vulnerabilities.push({
          id: generateVulnId(),
          type: 'redos',
          severity: 'high',
          cwes: ['CWE-1333'],
          owasp: ['A06:2021'],
          location: parser.getLocation(location),
          description: 'Potential ReDoS: Nested quantifiers detected',
          recommendation: 'Avoid nested quantifiers. Consider using RE2 or safe-regex library.',
          confidence: 0.8,
          ruleId: this.ruleId,
          codeSnippet: parser.extractSnippet(location),
          detectedAt: new Date(),
        });
      }
    };

    // Check new RegExp() calls
    for (const newExpr of newExpressions) {
      if (newExpr.getExpression().getText() === 'RegExp') {
        const args = newExpr.getArguments();
        if (args.length > 0) {
          checkRegexArg(args[0], newExpr);
        }
      }
    }

    // Check RegExp() calls
    for (const call of calls) {
      if (parser.getFunctionName(call) === 'RegExp') {
        const args = call.getArguments();
        if (args.length > 0) {
          checkRegexArg(args[0], call);
        }
      }
    }

    // Check regex literals
    const regexLiterals = sourceFile.getDescendantsOfKind(SyntaxKind.RegularExpressionLiteral);
    for (const regex of regexLiterals) {
      const regexText = regex.getText();
      
      for (const dangerous of dangerousPatterns) {
        if (dangerous.pattern.test(regexText)) {
          vulnerabilities.push({
            id: generateVulnId(),
            type: 'redos',
            severity: 'high',
            cwes: ['CWE-1333'],
            owasp: ['A06:2021'],
            location: parser.getLocation(regex),
            description: `Potential ReDoS: Pattern "${dangerous.description}" can cause catastrophic backtracking`,
            recommendation: 'Use atomic groups, possessive quantifiers, or rewrite the regex.',
            confidence: 0.85,
            ruleId: this.ruleId,
            codeSnippet: parser.extractSnippet(regex),
            detectedAt: new Date(),
          });
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * Race Condition detector
 * @trace CWE-362
 */
const raceConditionDetector: VulnerabilityDetector = {
  ruleId: 'SEC-012',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    // TOCTOU (Time-of-check to time-of-use) patterns
    const checkFunctions = ['exists', 'existsSync', 'access', 'accessSync', 'stat', 'statSync'];
    const useFunctions = ['readFile', 'readFileSync', 'writeFile', 'writeFileSync', 
                          'unlink', 'unlinkSync', 'rename', 'renameSync', 'open', 'openSync'];

    // Track check calls and their positions
    const checkCalls: { funcName: string; line: number; filePath?: string }[] = [];
    const useCalls: { funcName: string; line: number; filePath?: string; node: any }[] = [];

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const location = parser.getLocation(call);
      const args = call.getArguments();
      const firstArg = args.length > 0 ? args[0].getText() : undefined;

      if (funcName && checkFunctions.includes(funcName)) {
        checkCalls.push({ funcName, line: location.startLine, filePath: firstArg });
      }
      if (funcName && useFunctions.includes(funcName)) {
        useCalls.push({ funcName, line: location.startLine, filePath: firstArg, node: call });
      }
    }

    // Detect TOCTOU pattern: check followed by use on same file
    for (const check of checkCalls) {
      for (const use of useCalls) {
        // Same file path and use comes after check (within 20 lines)
        if (
          check.filePath && 
          use.filePath && 
          check.filePath === use.filePath &&
          use.line > check.line &&
          use.line - check.line < 20
        ) {
          vulnerabilities.push({
            id: generateVulnId(),
            type: 'race-condition',
            severity: 'medium',
            cwes: ['CWE-362', 'CWE-367'],
            owasp: ['A04:2021'],
            location: parser.getLocation(use.node),
            description: `Potential TOCTOU race condition: ${check.funcName}() followed by ${use.funcName}() on same file`,
            recommendation: 'Use atomic operations. Handle errors from the operation itself instead of pre-checking.',
            confidence: 0.7,
            ruleId: this.ruleId,
            codeSnippet: parser.extractSnippet(use.node),
            detectedAt: new Date(),
          });
        }
      }
    }

    // Detect shared state modifications without synchronization
    const sharedStatePatterns = [
      'global.', 'process.env', 'module.exports', 'exports.',
    ];

    const assignments = sourceFile.getDescendantsOfKind(SyntaxKind.BinaryExpression);
    for (const assignment of assignments) {
      if (assignment.getOperatorToken().getKind() === SyntaxKind.EqualsToken) {
        const left = assignment.getLeft().getText();
        
        for (const pattern of sharedStatePatterns) {
          if (left.startsWith(pattern)) {
            // Check if inside async function
            let parent = assignment.getParent();
            while (parent) {
              const kind = parent.getKind();
              if (
                kind === SyntaxKind.FunctionDeclaration ||
                kind === SyntaxKind.FunctionExpression ||
                kind === SyntaxKind.ArrowFunction
              ) {
                const funcText = parent.getText();
                if (funcText.includes('async') || funcText.includes('await')) {
                  vulnerabilities.push({
                    id: generateVulnId(),
                    type: 'race-condition',
                    severity: 'medium',
                    cwes: ['CWE-362'],
                    owasp: ['A04:2021'],
                    location: parser.getLocation(assignment),
                    description: `Potential race condition: Shared state modification (${left}) in async context`,
                    recommendation: 'Use proper synchronization mechanisms (mutex, semaphore) or atomic operations.',
                    confidence: 0.6,
                    ruleId: this.ruleId,
                    codeSnippet: parser.extractSnippet(assignment),
                    detectedAt: new Date(),
                  });
                  break;
                }
              }
              parent = parent.getParent();
            }
          }
        }
      }
    }

    // Detect concurrent file operations
    const promiseAllCalls = calls.filter(call => {
      const funcName = parser.getFunctionName(call);
      const receiverName = parser.getReceiverName(call);
      return funcName === 'all' && receiverName === 'Promise';
    });

    for (const promiseAll of promiseAllCalls) {
      const args = promiseAll.getArguments();
      if (args.length > 0) {
        const arrayText = args[0].getText();
        
        // Check if Promise.all contains file operations on potentially same files
        const hasFileOps = useFunctions.some(fn => arrayText.includes(fn));
        if (hasFileOps) {
          vulnerabilities.push({
            id: generateVulnId(),
            type: 'race-condition',
            severity: 'low',
            cwes: ['CWE-362'],
            owasp: ['A04:2021'],
            location: parser.getLocation(promiseAll),
            description: 'Potential race condition: Concurrent file operations in Promise.all()',
            recommendation: 'Ensure file operations in Promise.all() do not conflict. Use file locking if needed.',
            confidence: 0.5,
            ruleId: this.ruleId,
            codeSnippet: parser.extractSnippet(promiseAll),
            detectedAt: new Date(),
          });
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * All built-in detectors
 */
const DETECTORS: VulnerabilityDetector[] = [
  sqlInjectionDetector,
  commandInjectionDetector,
  pathTraversalDetector,
  xssDetector,
  evalDetector,
  prototypePollutionDetector,
  ssrfDetector,
  insecureDeserializationDetector,
  xxeDetector,
  ldapInjectionDetector,
  redosDetector,
  raceConditionDetector,
];

/**
 * Vulnerability scanner
 */
export class VulnerabilityScanner {
  private parser: ASTParser;
  private fileScanner: FileScanner;
  private detectors: VulnerabilityDetector[];

  constructor(options?: { tsConfigPath?: string }) {
    this.parser = getASTParser(options?.tsConfigPath);
    this.fileScanner = createFileScanner();
    this.detectors = [...DETECTORS];
  }

  /**
   * Scan a single file
   */
  scanFile(filePath: string): Vulnerability[] {
    const sourceFile = this.parser.parseFile(filePath);
    const vulnerabilities: Vulnerability[] = [];

    for (const detector of this.detectors) {
      const detected = detector.detect(sourceFile, this.parser);
      vulnerabilities.push(...detected);
    }

    return vulnerabilities;
  }

  /**
   * Scan a directory
   */
  async scanDirectory(rootPath: string, options?: ScanOptions): Promise<ScanResult> {
    const startTime = Date.now();
    const files = await this.fileScanner.scan(rootPath);
    
    const vulnerabilities: Vulnerability[] = [];
    let scannedFiles = 0;
    let skippedFiles = 0;

    for (const file of files) {
      // Apply exclude patterns
      if (options?.excludePatterns?.some((p) => file.relativePath.includes(p))) {
        skippedFiles++;
        continue;
      }

      // Apply max file size
      if (options?.maxFileSize && file.size > options.maxFileSize) {
        skippedFiles++;
        continue;
      }

      try {
        const fileVulns = this.scanFile(file.path);
        
        // Apply severity filter
        const filtered = options?.severityFilter
          ? fileVulns.filter((v) => options.severityFilter!.includes(v.severity))
          : fileVulns;
        
        vulnerabilities.push(...filtered);
        scannedFiles++;
      } catch (error) {
        console.warn(`Warning: Failed to scan ${file.path}: ${error}`);
        skippedFiles++;
      }
    }

    const duration = Date.now() - startTime;

    return {
      vulnerabilities,
      scannedFiles,
      skippedFiles,
      duration,
      timestamp: new Date(),
      options: options ?? {},
      summary: {
        critical: vulnerabilities.filter((v) => v.severity === 'critical').length,
        high: vulnerabilities.filter((v) => v.severity === 'high').length,
        medium: vulnerabilities.filter((v) => v.severity === 'medium').length,
        low: vulnerabilities.filter((v) => v.severity === 'low').length,
        info: vulnerabilities.filter((v) => v.severity === 'info').length,
        total: vulnerabilities.length,
      },
    };
  }

  /**
   * Add a custom detector
   */
  addDetector(detector: VulnerabilityDetector): void {
    this.detectors.push(detector);
  }

  /**
   * Get list of rule IDs
   */
  getRuleIds(): string[] {
    return this.detectors.map((d) => d.ruleId);
  }

  /**
   * Get number of rules
   */
  getRuleCount(): number {
    return this.detectors.length;
  }
}

/**
 * Create a vulnerability scanner
 */
export function createVulnerabilityScanner(options?: { tsConfigPath?: string }): VulnerabilityScanner {
  return new VulnerabilityScanner(options);
}
