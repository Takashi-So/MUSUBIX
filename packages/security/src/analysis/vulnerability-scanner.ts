/**
 * @fileoverview Vulnerability scanner - static analysis for security vulnerabilities
 * @module @nahisaho/musubix-security/analysis/vulnerability-scanner
 * @trace REQ-SEC-SCAN-001, REQ-SEC-SCAN-002, REQ-SEC-SCAN-003
 */

import type { SourceFile } from 'ts-morph';
import { SyntaxKind } from 'ts-morph';
import type {
  Vulnerability,
  ScanOptions,
  ScanResult,
} from '../types/index.js';
import { ASTParser, getASTParser } from '../infrastructure/ast-parser.js';
import { FileScanner, createFileScanner } from '../infrastructure/file-scanner.js';

/**
 * Vulnerability detector interface
 */
interface VulnerabilityDetector {
  ruleId: string;
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[];
}

/**
 * Generate vulnerability ID
 */
let vulnCounter = 0;
function generateVulnId(): string {
  const date = new Date();
  const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
  return `VULN-${dateStr}-${String(++vulnCounter).padStart(3, '0')}`;
}

/**
 * Reset vulnerability counter (for testing)
 */
export function resetVulnCounter(): void {
  vulnCounter = 0;
}

/**
 * SQL Injection detector
 * @trace REQ-SEC-SCAN-002
 */
const sqlInjectionDetector: VulnerabilityDetector = {
  ruleId: 'SEC-001',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const sqlMethods = ['query', 'execute', 'raw', 'exec'];

      if (funcName && sqlMethods.includes(funcName)) {
        const args = call.getArguments();
        if (args.length > 0) {
          const firstArg = args[0];

          // Check for template literal (potential string concatenation)
          if (firstArg.getKind() === SyntaxKind.TemplateExpression) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'injection',
              severity: 'critical',
              cwes: ['CWE-89'],
              owasp: ['A03:2021'],
              location: parser.getLocation(call),
              description: 'Potential SQL injection: Template literal used in SQL query',
              recommendation: 'Use parameterized queries instead of string interpolation',
              confidence: 0.85,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }

          // Check for binary expression (string concatenation)
          if (firstArg.getKind() === SyntaxKind.BinaryExpression) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'injection',
              severity: 'critical',
              cwes: ['CWE-89'],
              owasp: ['A03:2021'],
              location: parser.getLocation(call),
              description: 'Potential SQL injection: String concatenation in SQL query',
              recommendation: 'Use parameterized queries instead of string concatenation',
              confidence: 0.9,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * Command injection detector
 */
const commandInjectionDetector: VulnerabilityDetector = {
  ruleId: 'SEC-002',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const cmdMethods = ['exec', 'execSync', 'spawn', 'spawnSync', 'execFile'];

      if (funcName && cmdMethods.includes(funcName)) {
        const args = call.getArguments();
        if (args.length > 0) {
          const firstArg = args[0];

          // Check for template literal or binary expression
          if (
            firstArg.getKind() === SyntaxKind.TemplateExpression ||
            firstArg.getKind() === SyntaxKind.BinaryExpression
          ) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'command-injection',
              severity: 'critical',
              cwes: ['CWE-78'],
              owasp: ['A03:2021'],
              location: parser.getLocation(call),
              description: 'Potential command injection: Unsafe command construction',
              recommendation: 'Use execFile with array arguments or properly escape shell arguments',
              confidence: 0.85,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * Path traversal detector
 */
const pathTraversalDetector: VulnerabilityDetector = {
  ruleId: 'SEC-003',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const fsMethods = [
        'readFile', 'readFileSync', 'writeFile', 'writeFileSync',
        'readdir', 'readdirSync', 'unlink', 'unlinkSync',
        'stat', 'statSync', 'access', 'accessSync',
      ];

      if (funcName && fsMethods.includes(funcName)) {
        const args = call.getArguments();
        if (args.length > 0) {
          const firstArg = args[0];

          // Check for template literal or binary expression
          if (
            firstArg.getKind() === SyntaxKind.TemplateExpression ||
            firstArg.getKind() === SyntaxKind.BinaryExpression
          ) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'path-traversal',
              severity: 'high',
              cwes: ['CWE-22'],
              owasp: ['A01:2021'],
              location: parser.getLocation(call),
              description: 'Potential path traversal: User input may be used in file path',
              recommendation: 'Validate and sanitize file paths, use path.resolve() with base directory check',
              confidence: 0.75,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }
    }

    return vulnerabilities;
  },
};

/**
 * XSS detector
 */
const xssDetector: VulnerabilityDetector = {
  ruleId: 'SEC-004',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);
      const receiverName = parser.getReceiverName(call);

      // Check res.send(), res.write(), res.end() with template literals
      if (
        receiverName === 'res' &&
        funcName &&
        ['send', 'write', 'end', 'render'].includes(funcName)
      ) {
        const args = call.getArguments();
        if (args.length > 0) {
          const firstArg = args[0];
          if (firstArg.getKind() === SyntaxKind.TemplateExpression) {
            vulnerabilities.push({
              id: generateVulnId(),
              type: 'xss',
              severity: 'high',
              cwes: ['CWE-79'],
              owasp: ['A03:2021'],
              location: parser.getLocation(call),
              description: 'Potential XSS: Unescaped output to response',
              recommendation: 'Use HTML escaping or a template engine with auto-escaping',
              confidence: 0.7,
              ruleId: this.ruleId,
              codeSnippet: parser.extractSnippet(call),
              detectedAt: new Date(),
            });
          }
        }
      }

      // Check innerHTML assignment (requires property access analysis)
      const expr = call.getExpression();
      if (expr.getText().includes('innerHTML')) {
        vulnerabilities.push({
          id: generateVulnId(),
          type: 'xss',
          severity: 'high',
          cwes: ['CWE-79'],
          owasp: ['A03:2021'],
          location: parser.getLocation(call),
          description: 'Potential XSS: innerHTML assignment detected',
          recommendation: 'Use textContent or properly sanitize HTML content',
          confidence: 0.8,
          ruleId: this.ruleId,
          codeSnippet: parser.extractSnippet(call),
          detectedAt: new Date(),
        });
      }
    }

    return vulnerabilities;
  },
};

/**
 * Eval detector
 */
const evalDetector: VulnerabilityDetector = {
  ruleId: 'SEC-005',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);

      if (funcName === 'eval' || funcName === 'Function') {
        vulnerabilities.push({
          id: generateVulnId(),
          type: 'code-injection',
          severity: 'critical',
          cwes: ['CWE-94', 'CWE-95'],
          owasp: ['A03:2021'],
          location: parser.getLocation(call),
          description: `Potential code injection: ${funcName}() usage detected`,
          recommendation: 'Avoid eval() and new Function(). Use safer alternatives.',
          confidence: 0.95,
          ruleId: this.ruleId,
          codeSnippet: parser.extractSnippet(call),
          detectedAt: new Date(),
        });
      }
    }

    return vulnerabilities;
  },
};

/**
 * Prototype pollution detector
 */
const prototypePollutionDetector: VulnerabilityDetector = {
  ruleId: 'SEC-006',
  detect(sourceFile: SourceFile, parser: ASTParser): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of calls) {
      const funcName = parser.getFunctionName(call);

      // Object.assign with user input
      if (funcName === 'assign') {
        const receiverName = parser.getReceiverName(call);
        if (receiverName === 'Object') {
          // Check if first argument is Object.prototype or {}
          vulnerabilities.push({
            id: generateVulnId(),
            type: 'prototype-pollution',
            severity: 'high',
            cwes: ['CWE-1321'],
            owasp: ['A08:2021'],
            location: parser.getLocation(call),
            description: 'Potential prototype pollution: Object.assign() with external input',
            recommendation: 'Validate object keys, use Map instead, or freeze prototype',
            confidence: 0.6,
            ruleId: this.ruleId,
            codeSnippet: parser.extractSnippet(call),
            detectedAt: new Date(),
          });
        }
      }
    }

    // Check for __proto__ access
    const propertyAccess = sourceFile.getDescendantsOfKind(SyntaxKind.PropertyAccessExpression);
    for (const access of propertyAccess) {
      if (access.getName() === '__proto__') {
        vulnerabilities.push({
          id: generateVulnId(),
          type: 'prototype-pollution',
          severity: 'high',
          cwes: ['CWE-1321'],
          owasp: ['A08:2021'],
          location: parser.getLocation(access),
          description: 'Potential prototype pollution: __proto__ access detected',
          recommendation: 'Avoid __proto__ access, use Object.getPrototypeOf() if needed',
          confidence: 0.85,
          ruleId: this.ruleId,
          codeSnippet: parser.extractSnippet(access),
          detectedAt: new Date(),
        });
      }
    }

    return vulnerabilities;
  },
};

/**
 * All built-in detectors
 */
const DETECTORS: VulnerabilityDetector[] = [
  sqlInjectionDetector,
  commandInjectionDetector,
  pathTraversalDetector,
  xssDetector,
  evalDetector,
  prototypePollutionDetector,
];

/**
 * Vulnerability scanner
 */
export class VulnerabilityScanner {
  private parser: ASTParser;
  private fileScanner: FileScanner;
  private detectors: VulnerabilityDetector[];

  constructor(options?: { tsConfigPath?: string }) {
    this.parser = getASTParser(options?.tsConfigPath);
    this.fileScanner = createFileScanner();
    this.detectors = [...DETECTORS];
  }

  /**
   * Scan a single file
   */
  scanFile(filePath: string): Vulnerability[] {
    const sourceFile = this.parser.parseFile(filePath);
    const vulnerabilities: Vulnerability[] = [];

    for (const detector of this.detectors) {
      const detected = detector.detect(sourceFile, this.parser);
      vulnerabilities.push(...detected);
    }

    return vulnerabilities;
  }

  /**
   * Scan a directory
   */
  async scanDirectory(rootPath: string, options?: ScanOptions): Promise<ScanResult> {
    const startTime = Date.now();
    const files = await this.fileScanner.scan(rootPath);
    
    const vulnerabilities: Vulnerability[] = [];
    let scannedFiles = 0;
    let skippedFiles = 0;

    for (const file of files) {
      // Apply exclude patterns
      if (options?.excludePatterns?.some((p) => file.relativePath.includes(p))) {
        skippedFiles++;
        continue;
      }

      // Apply max file size
      if (options?.maxFileSize && file.size > options.maxFileSize) {
        skippedFiles++;
        continue;
      }

      try {
        const fileVulns = this.scanFile(file.path);
        
        // Apply severity filter
        const filtered = options?.severityFilter
          ? fileVulns.filter((v) => options.severityFilter!.includes(v.severity))
          : fileVulns;
        
        vulnerabilities.push(...filtered);
        scannedFiles++;
      } catch (error) {
        console.warn(`Warning: Failed to scan ${file.path}: ${error}`);
        skippedFiles++;
      }
    }

    const duration = Date.now() - startTime;

    return {
      vulnerabilities,
      scannedFiles,
      skippedFiles,
      duration,
      timestamp: new Date(),
      options: options ?? {},
      summary: {
        critical: vulnerabilities.filter((v) => v.severity === 'critical').length,
        high: vulnerabilities.filter((v) => v.severity === 'high').length,
        medium: vulnerabilities.filter((v) => v.severity === 'medium').length,
        low: vulnerabilities.filter((v) => v.severity === 'low').length,
        info: vulnerabilities.filter((v) => v.severity === 'info').length,
        total: vulnerabilities.length,
      },
    };
  }

  /**
   * Add a custom detector
   */
  addDetector(detector: VulnerabilityDetector): void {
    this.detectors.push(detector);
  }

  /**
   * Get list of rule IDs
   */
  getRuleIds(): string[] {
    return this.detectors.map((d) => d.ruleId);
  }

  /**
   * Get number of rules
   */
  getRuleCount(): number {
    return this.detectors.length;
  }
}

/**
 * Create a vulnerability scanner
 */
export function createVulnerabilityScanner(options?: { tsConfigPath?: string }): VulnerabilityScanner {
  return new VulnerabilityScanner(options);
}
