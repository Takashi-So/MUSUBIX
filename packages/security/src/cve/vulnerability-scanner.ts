/**
 * @fileoverview Vulnerability Scanner for npm projects
 * @module @nahisaho/musubix-security/cve/vulnerability-scanner
 *
 * Integrates all CVE components to provide a unified vulnerability
 * scanning interface for npm projects.
 *
 * @requirement REQ-CVE-004 - Unified vulnerability scanning
 * @design DES-EPIC2-006 - Vulnerability Scanner component
 */

import { NVDClient, type NVDClientOptions } from './nvd-client.js';
import { RateLimiter } from './rate-limiter.js';
import { CPEMatcher, type VulnerabilityMatch, type VersionRange } from './cpe-matcher.js';
import {
  DependencyParser,
  filterDependenciesForScanning,
  getUniquePackages,
  type DependencyParserOptions,
  type ParsedDependency,
} from './dependency-parser.js';
import type { CVE, CVSSSeverity } from '../types/cve.js';

/**
 * Vulnerability scanner options
 */
export interface VulnerabilityScannerOptions {
  /** NVD client options */
  nvdClientOptions?: NVDClientOptions;
  /** Dependency parser options */
  parserOptions?: DependencyParserOptions;
  /** Include dev dependencies in scan (default: false for production scan) */
  includeDevDependencies?: boolean;
  /** Include transitive dependencies (default: true) */
  includeTransitive?: boolean;
  /** Minimum CVSS score to report (default: 0) */
  minCvssScore?: number;
  /** Severities to include (default: all) */
  severities?: CVSSSeverity[];
  /** Maximum concurrent NVD requests (default: 5) */
  maxConcurrent?: number;
  /** Progress callback */
  onProgress?: (progress: ScanProgress) => void;
  /** Custom vendor mappings for CPE matching */
  vendorMappings?: Record<string, string>;
}

/**
 * Scan progress information
 */
export interface ScanProgress {
  /** Current phase */
  phase: 'parsing' | 'scanning' | 'matching' | 'complete';
  /** Total packages to scan */
  totalPackages: number;
  /** Packages scanned so far */
  scannedPackages: number;
  /** Vulnerabilities found so far */
  vulnerabilitiesFound: number;
  /** Current package being scanned */
  currentPackage?: string;
}

/**
 * Detected vulnerability information
 */
export interface DetectedVulnerability {
  /** CVE ID */
  cveId: string;
  /** Package name */
  packageName: string;
  /** Installed package version */
  installedVersion: string;
  /** CVE description */
  description: string;
  /** CVSS v3.1 score */
  cvssScore?: number;
  /** CVSS severity */
  severity?: CVSSSeverity;
  /** CVSS vector string */
  cvssVector?: string;
  /** Affected version range */
  affectedVersions?: VersionRange;
  /** Fixed version (if known) */
  fixedVersion?: string;
  /** CWE IDs */
  cwes?: string[];
  /** References (URLs) */
  references?: string[];
  /** Whether this is a direct dependency */
  isDirect: boolean;
  /** Dependency type */
  dependencyType: string;
  /** Published date */
  publishedDate?: string;
  /** Last modified date */
  lastModifiedDate?: string;
  /** Match confidence (0-1) */
  confidence: number;
}

/**
 * Scan result
 */
export interface ScanResult {
  /** Project name */
  projectName?: string;
  /** Project version */
  projectVersion?: string;
  /** Scan timestamp */
  scanTimestamp: string;
  /** Total packages scanned */
  totalPackages: number;
  /** Direct dependencies count */
  directDependencies: number;
  /** Transitive dependencies count */
  transitiveDependencies: number;
  /** Detected vulnerabilities */
  vulnerabilities: DetectedVulnerability[];
  /** Summary by severity */
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    none: number;
    total: number;
  };
  /** Scan duration in ms */
  durationMs: number;
  /** Packages that failed to scan */
  errors: { packageName: string; error: string }[];
  /** Warnings during scan */
  warnings: string[];
}

/**
 * Vulnerability Scanner
 *
 * @example
 * ```typescript
 * const scanner = new VulnerabilityScanner({
 *   nvdClientOptions: { apiKey: process.env.NVD_API_KEY },
 *   includeDevDependencies: false,
 * });
 *
 * // Scan a project directory
 * const result = await scanner.scanDirectory('./my-project');
 *
 * // Check specific packages
 * const vulns = await scanner.scanPackages([
 *   { name: 'express', version: '4.17.1' },
 *   { name: 'lodash', version: '4.17.20' },
 * ]);
 * ```
 */
export class VulnerabilityScanner {
  private readonly nvdClient: NVDClient;
  private readonly rateLimiter: RateLimiter;
  private readonly cpeMatcher: CPEMatcher;
  private readonly dependencyParser: DependencyParser;
  private readonly options: Required<
    Omit<VulnerabilityScannerOptions, 'nvdClientOptions' | 'parserOptions' | 'onProgress' | 'vendorMappings'>
  > & {
    onProgress?: (progress: ScanProgress) => void;
  };

  constructor(options: VulnerabilityScannerOptions = {}) {
    this.nvdClient = new NVDClient(options.nvdClientOptions);
    this.rateLimiter = RateLimiter.forNVD(!!options.nvdClientOptions?.apiKey);
    this.cpeMatcher = new CPEMatcher(options.vendorMappings);
    this.dependencyParser = new DependencyParser(options.parserOptions);

    this.options = {
      includeDevDependencies: options.includeDevDependencies ?? false,
      includeTransitive: options.includeTransitive ?? true,
      minCvssScore: options.minCvssScore ?? 0,
      severities: options.severities ?? ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'NONE'],
      maxConcurrent: options.maxConcurrent ?? 5,
      onProgress: options.onProgress,
    };
  }

  /**
   * Scan a project directory for vulnerabilities
   * @param dirPath - Path to project directory
   * @returns Scan result with all detected vulnerabilities
   */
  async scanDirectory(dirPath: string): Promise<ScanResult> {
    const startTime = Date.now();
    const warnings: string[] = [];
    const errors: { packageName: string; error: string }[] = [];

    // Phase 1: Parse dependencies
    this.reportProgress({
      phase: 'parsing',
      totalPackages: 0,
      scannedPackages: 0,
      vulnerabilitiesFound: 0,
    });

    const parseResult = await this.dependencyParser.parseDirectory(dirPath);
    warnings.push(...parseResult.warnings);

    // Filter dependencies
    const depsToScan = filterDependenciesForScanning(parseResult.dependencies, {
      includeDevDependencies: this.options.includeDevDependencies,
      includeTransitive: this.options.includeTransitive,
    });

    const uniqueDeps = getUniquePackages(depsToScan);

    // Phase 2: Scan packages
    const vulnerabilities: DetectedVulnerability[] = [];
    const totalPackages = uniqueDeps.length;

    this.reportProgress({
      phase: 'scanning',
      totalPackages,
      scannedPackages: 0,
      vulnerabilitiesFound: 0,
    });

    // Process in batches to respect rate limits
    const batchSize = this.options.maxConcurrent;
    for (let i = 0; i < uniqueDeps.length; i += batchSize) {
      const batch = uniqueDeps.slice(i, i + batchSize);
      
      const batchResults = await Promise.all(
        batch.map(async (dep) => {
          try {
            return await this.scanPackage(dep);
          } catch (error) {
            errors.push({
              packageName: dep.name,
              error: error instanceof Error ? error.message : String(error),
            });
            return [];
          }
        })
      );

      for (const results of batchResults) {
        vulnerabilities.push(...results);
      }

      this.reportProgress({
        phase: 'scanning',
        totalPackages,
        scannedPackages: Math.min(i + batchSize, totalPackages),
        vulnerabilitiesFound: vulnerabilities.length,
        currentPackage: batch[batch.length - 1]?.name,
      });
    }

    // Apply filters
    const filteredVulns = this.filterVulnerabilities(vulnerabilities);

    // Calculate summary
    const summary = this.calculateSummary(filteredVulns);

    this.reportProgress({
      phase: 'complete',
      totalPackages,
      scannedPackages: totalPackages,
      vulnerabilitiesFound: filteredVulns.length,
    });

    return {
      projectName: parseResult.projectName,
      projectVersion: parseResult.projectVersion,
      scanTimestamp: new Date().toISOString(),
      totalPackages,
      directDependencies: parseResult.directCount,
      transitiveDependencies: parseResult.transitiveCount,
      vulnerabilities: filteredVulns,
      summary,
      durationMs: Date.now() - startTime,
      errors,
      warnings,
    };
  }

  /**
   * Scan specific packages for vulnerabilities
   * @param packages - Packages to scan
   * @returns Detected vulnerabilities
   */
  async scanPackages(
    packages: Array<{ name: string; version: string }>
  ): Promise<DetectedVulnerability[]> {
    const vulnerabilities: DetectedVulnerability[] = [];

    for (const pkg of packages) {
      const dep: ParsedDependency = {
        name: pkg.name,
        versionSpecifier: pkg.version,
        resolvedVersion: pkg.version,
        type: 'dependencies',
        isDirect: true,
      };

      try {
        const results = await this.scanPackage(dep);
        vulnerabilities.push(...results);
      } catch {
        // Skip failed packages
      }
    }

    return this.filterVulnerabilities(vulnerabilities);
  }

  /**
   * Scan a single package for vulnerabilities
   */
  private async scanPackage(dep: ParsedDependency): Promise<DetectedVulnerability[]> {
    const version = dep.resolvedVersion ?? dep.versionSpecifier;
    const vulnerabilities: DetectedVulnerability[] = [];

    // Wait for rate limit
    await this.rateLimiter.waitForToken();

    // Search NVD by keyword (package name)
    const searchResult = await this.nvdClient.searchByKeyword(dep.name, {
      resultsPerPage: 100,
    });

    for (const cve of searchResult.cves) {
      // Check if this CVE affects the package
      const match = this.matchCVEToPackage(cve, dep.name, version);
      
      if (match && match.isVulnerable) {
        vulnerabilities.push(this.createDetectedVulnerability(cve, dep, match));
      }
    }

    return vulnerabilities;
  }

  /**
   * Match a CVE to a specific package version
   */
  private matchCVEToPackage(
    cve: CVE,
    packageName: string,
    version: string
  ): VulnerabilityMatch | null {
    // Check if CVE description mentions the package
    const descLower = cve.description.toLowerCase();
    const pkgLower = packageName.toLowerCase();
    
    if (!descLower.includes(pkgLower)) {
      return null;
    }

    // Check affectedProducts for CPE matches
    if (cve.affectedProducts && cve.affectedProducts.length > 0) {
      for (const product of cve.affectedProducts) {
        const match = this.cpeMatcher.matchPackage(
          packageName,
          version,
          {
            criteria: product.cpe,
            vulnerable: product.vulnerable,
            matchCriteriaId: '',
            versionRange: {
              versionStart: product.versionStartIncluding ?? product.versionStartExcluding,
              versionEnd: product.versionEndIncluding ?? product.versionEndExcluding,
              versionStartExcluding: !!product.versionStartExcluding,
              versionEndExcluding: !!product.versionEndExcluding,
            },
          }
        );

        if (match && match.isVulnerable) {
          return match;
        }
      }
    }

    // Fallback: assume vulnerable if package is mentioned
    return {
      packageName,
      packageVersion: version,
      cveId: cve.id,
      cpe: this.cpeMatcher.generateCPE(packageName, version),
      isVulnerable: true,
      confidence: 0.5, // Lower confidence without CPE match
    };
  }

  /**
   * Create a detected vulnerability from CVE data
   */
  private createDetectedVulnerability(
    cve: CVE,
    dep: ParsedDependency,
    match: VulnerabilityMatch
  ): DetectedVulnerability {
    const version = dep.resolvedVersion ?? dep.versionSpecifier;

    return {
      cveId: cve.id,
      packageName: dep.name,
      installedVersion: version,
      description: cve.description,
      cvssScore: cve.cvss?.baseScore,
      severity: cve.cvss?.severity,
      cvssVector: cve.cvss?.vectorString,
      affectedVersions: match.matchCriteria?.versionRange,
      cwes: cve.cwes,
      references: cve.references?.map((r) => r.url),
      isDirect: dep.isDirect,
      dependencyType: dep.type,
      publishedDate: cve.published instanceof Date ? cve.published.toISOString() : String(cve.published),
      lastModifiedDate: cve.lastModified instanceof Date ? cve.lastModified.toISOString() : String(cve.lastModified),
      confidence: match.confidence,
    };
  }

  /**
   * Filter vulnerabilities based on options
   */
  private filterVulnerabilities(
    vulnerabilities: DetectedVulnerability[]
  ): DetectedVulnerability[] {
    return vulnerabilities.filter((vuln) => {
      // Filter by CVSS score
      if (vuln.cvssScore !== undefined && vuln.cvssScore < this.options.minCvssScore) {
        return false;
      }

      // Filter by severity
      if (vuln.severity && !this.options.severities.includes(vuln.severity)) {
        return false;
      }

      return true;
    });
  }

  /**
   * Calculate summary statistics
   */
  private calculateSummary(vulnerabilities: DetectedVulnerability[]): ScanResult['summary'] {
    const summary = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      none: 0,
      total: vulnerabilities.length,
    };

    for (const vuln of vulnerabilities) {
      switch (vuln.severity) {
        case 'CRITICAL':
          summary.critical++;
          break;
        case 'HIGH':
          summary.high++;
          break;
        case 'MEDIUM':
          summary.medium++;
          break;
        case 'LOW':
          summary.low++;
          break;
        case 'NONE':
        default:
          summary.none++;
          break;
      }
    }

    return summary;
  }

  /**
   * Report progress to callback
   */
  private reportProgress(progress: ScanProgress): void {
    this.options.onProgress?.(progress);
  }
}

/**
 * Quick scan function for simple use cases
 */
export async function scanProjectForVulnerabilities(
  dirPath: string,
  options?: VulnerabilityScannerOptions
): Promise<ScanResult> {
  const scanner = new VulnerabilityScanner(options);
  return scanner.scanDirectory(dirPath);
}
