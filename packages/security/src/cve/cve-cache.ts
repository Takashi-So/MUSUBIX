/**
 * @fileoverview CVE Cache with SQLite storage
 * @module @nahisaho/musubix-security/cve/cve-cache
 * @description Provides persistent caching for CVE data to reduce NVD API calls
 * @requirements REQ-SEC-CVE-002 - Rate limiting and caching for NVD API
 * @design DES-SEC-CVE-002 - CVE cache with configurable TTL
 * @task TSK-CVE-007 - SQLite キャッシュ
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import type { CVE } from '../types/cve.js';

/**
 * Cache entry with metadata
 */
export interface CacheEntry<T> {
  /** Cached data */
  data: T;
  /** Timestamp when the entry was created */
  createdAt: number;
  /** Timestamp when the entry expires */
  expiresAt: number;
  /** Optional ETag for conditional requests */
  etag?: string;
}

/**
 * CVE Cache configuration options
 */
export interface CVECacheOptions {
  /** Path to the SQLite database file */
  dbPath?: string;
  /** Default TTL in milliseconds (default: 24 hours) */
  defaultTTL?: number;
  /** Maximum number of entries (default: 10000) */
  maxEntries?: number;
  /** Enable automatic cleanup (default: true) */
  autoCleanup?: boolean;
  /** Cleanup interval in milliseconds (default: 1 hour) */
  cleanupInterval?: number;
}

/**
 * Cache statistics
 */
export interface CacheStats {
  /** Total number of entries */
  totalEntries: number;
  /** Number of expired entries */
  expiredEntries: number;
  /** Number of valid entries */
  validEntries: number;
  /** Cache hit rate */
  hitRate: number;
  /** Total cache size in bytes */
  sizeBytes: number;
  /** Oldest entry timestamp */
  oldestEntry: number | null;
  /** Newest entry timestamp */
  newestEntry: number | null;
}

/**
 * Internal cache tracking
 */
interface CacheMetrics {
  hits: number;
  misses: number;
}

/**
 * CVE Cache implementation using file-based JSON storage
 * @description Uses JSON files for persistence to avoid native module dependencies
 */
export class CVECache {
  private readonly dbPath: string;
  private readonly defaultTTL: number;
  private readonly maxEntries: number;
  private readonly autoCleanup: boolean;
  private readonly cleanupInterval: number;
  private cleanupTimer?: ReturnType<typeof setInterval>;
  private metrics: CacheMetrics = { hits: 0, misses: 0 };
  
  // In-memory cache for fast access
  private cache: Map<string, CacheEntry<unknown>> = new Map();

  /**
   * Default 24 hours TTL
   */
  static readonly DEFAULT_TTL = 24 * 60 * 60 * 1000;

  /**
   * Default maximum entries
   */
  static readonly DEFAULT_MAX_ENTRIES = 10000;

  /**
   * Default cleanup interval (1 hour)
   */
  static readonly DEFAULT_CLEANUP_INTERVAL = 60 * 60 * 1000;

  constructor(options: CVECacheOptions = {}) {
    this.dbPath = options.dbPath ?? path.join(process.cwd(), '.musubix', 'cve-cache.json');
    this.defaultTTL = options.defaultTTL ?? CVECache.DEFAULT_TTL;
    this.maxEntries = options.maxEntries ?? CVECache.DEFAULT_MAX_ENTRIES;
    this.autoCleanup = options.autoCleanup ?? true;
    this.cleanupInterval = options.cleanupInterval ?? CVECache.DEFAULT_CLEANUP_INTERVAL;

    this.initializeStorage();
    this.loadFromDisk();

    if (this.autoCleanup) {
      this.startCleanupTimer();
    }
  }

  /**
   * Initialize storage directory and file
   */
  private initializeStorage(): void {
    const dir = path.dirname(this.dbPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    if (!fs.existsSync(this.dbPath)) {
      fs.writeFileSync(this.dbPath, JSON.stringify({}));
    }
  }

  /**
   * Load cache from disk
   */
  private loadFromDisk(): void {
    try {
      const data = fs.readFileSync(this.dbPath, 'utf-8');
      const parsed = JSON.parse(data) as Record<string, CacheEntry<unknown>>;
      this.cache = new Map(Object.entries(parsed));
    } catch {
      this.cache = new Map();
    }
  }

  /**
   * Save cache to disk
   */
  private saveToDisk(): void {
    try {
      const data = Object.fromEntries(this.cache);
      fs.writeFileSync(this.dbPath, JSON.stringify(data, null, 2));
    } catch {
      // Silently fail - cache is still available in memory
    }
  }

  /**
   * Start automatic cleanup timer
   */
  private startCleanupTimer(): void {
    this.cleanupTimer = setInterval(() => {
      this.cleanup();
    }, this.cleanupInterval);
    
    // Ensure timer doesn't prevent process exit
    if (this.cleanupTimer.unref) {
      this.cleanupTimer.unref();
    }
  }

  /**
   * Stop automatic cleanup timer
   */
  private stopCleanupTimer(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = undefined;
    }
  }

  /**
   * Generate cache key for CVE ID
   */
  private cveKey(cveId: string): string {
    return `cve:${cveId}`;
  }

  /**
   * Generate cache key for CPE search
   */
  private cpeKey(cpeName: string): string {
    return `cpe:${cpeName}`;
  }

  /**
   * Generate cache key for keyword search
   */
  private keywordKey(keyword: string): string {
    return `keyword:${keyword.toLowerCase()}`;
  }

  /**
   * Get a CVE from cache
   * @param cveId - CVE identifier (e.g., CVE-2024-12345)
   * @returns Cached CVE or undefined if not found/expired
   */
  getCVE(cveId: string): CVE | undefined {
    const key = this.cveKey(cveId);
    const entry = this.cache.get(key) as CacheEntry<CVE> | undefined;
    
    if (!entry) {
      this.metrics.misses++;
      return undefined;
    }

    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      this.metrics.misses++;
      return undefined;
    }

    this.metrics.hits++;
    return entry.data;
  }

  /**
   * Store a CVE in cache
   * @param cve - CVE to cache
   * @param ttl - Optional custom TTL in milliseconds
   * @param etag - Optional ETag for conditional requests
   */
  setCVE(cve: CVE, ttl?: number, etag?: string): void {
    const key = this.cveKey(cve.id);
    const now = Date.now();
    const entry: CacheEntry<CVE> = {
      data: cve,
      createdAt: now,
      expiresAt: now + (ttl ?? this.defaultTTL),
      etag,
    };

    this.cache.set(key, entry);
    this.enforceMaxEntries();
    this.saveToDisk();
  }

  /**
   * Get CVEs for a CPE from cache
   * @param cpeName - CPE name string
   * @returns Cached CVE array or undefined
   */
  getCVEsByCPE(cpeName: string): CVE[] | undefined {
    const key = this.cpeKey(cpeName);
    const entry = this.cache.get(key) as CacheEntry<CVE[]> | undefined;

    if (!entry) {
      this.metrics.misses++;
      return undefined;
    }

    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      this.metrics.misses++;
      return undefined;
    }

    this.metrics.hits++;
    return entry.data;
  }

  /**
   * Store CVEs for a CPE in cache
   * @param cpeName - CPE name string
   * @param cves - Array of CVEs to cache
   * @param ttl - Optional custom TTL
   */
  setCVEsByCPE(cpeName: string, cves: CVE[], ttl?: number): void {
    const key = this.cpeKey(cpeName);
    const now = Date.now();
    const entry: CacheEntry<CVE[]> = {
      data: cves,
      createdAt: now,
      expiresAt: now + (ttl ?? this.defaultTTL),
    };

    this.cache.set(key, entry);
    this.enforceMaxEntries();
    this.saveToDisk();
  }

  /**
   * Get CVEs for a keyword search from cache
   * @param keyword - Search keyword
   * @returns Cached CVE array or undefined
   */
  getCVEsByKeyword(keyword: string): CVE[] | undefined {
    const key = this.keywordKey(keyword);
    const entry = this.cache.get(key) as CacheEntry<CVE[]> | undefined;

    if (!entry) {
      this.metrics.misses++;
      return undefined;
    }

    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      this.metrics.misses++;
      return undefined;
    }

    this.metrics.hits++;
    return entry.data;
  }

  /**
   * Store CVEs for a keyword search in cache
   * @param keyword - Search keyword
   * @param cves - Array of CVEs to cache
   * @param ttl - Optional custom TTL (shorter recommended for searches)
   */
  setCVEsByKeyword(keyword: string, cves: CVE[], ttl?: number): void {
    const key = this.keywordKey(keyword);
    const now = Date.now();
    // Default to 1 hour for keyword searches (more volatile)
    const searchTTL = ttl ?? Math.min(this.defaultTTL, 60 * 60 * 1000);
    const entry: CacheEntry<CVE[]> = {
      data: cves,
      createdAt: now,
      expiresAt: now + searchTTL,
    };

    this.cache.set(key, entry);
    this.enforceMaxEntries();
    this.saveToDisk();
  }

  /**
   * Check if a CVE is in cache and not expired
   * @param cveId - CVE identifier
   * @returns true if cached and valid
   */
  hasCVE(cveId: string): boolean {
    const key = this.cveKey(cveId);
    const entry = this.cache.get(key);
    if (!entry) return false;
    return Date.now() <= entry.expiresAt;
  }

  /**
   * Delete a CVE from cache
   * @param cveId - CVE identifier
   * @returns true if entry was deleted
   */
  deleteCVE(cveId: string): boolean {
    const key = this.cveKey(cveId);
    const deleted = this.cache.delete(key);
    if (deleted) {
      this.saveToDisk();
    }
    return deleted;
  }

  /**
   * Get cache entry metadata
   * @param cveId - CVE identifier
   * @returns Cache entry metadata or undefined
   */
  getCVEMetadata(cveId: string): Omit<CacheEntry<unknown>, 'data'> | undefined {
    const key = this.cveKey(cveId);
    const entry = this.cache.get(key);
    if (!entry) return undefined;
    
    return {
      createdAt: entry.createdAt,
      expiresAt: entry.expiresAt,
      etag: entry.etag,
    };
  }

  /**
   * Remove expired entries
   * @returns Number of entries removed
   */
  cleanup(): number {
    const now = Date.now();
    let removed = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiresAt) {
        this.cache.delete(key);
        removed++;
      }
    }

    if (removed > 0) {
      this.saveToDisk();
    }
    return removed;
  }

  /**
   * Enforce maximum entries limit (LRU eviction)
   */
  private enforceMaxEntries(): void {
    if (this.cache.size <= this.maxEntries) return;

    // Sort by createdAt and remove oldest
    const entries = Array.from(this.cache.entries())
      .sort((a, b) => a[1].createdAt - b[1].createdAt);

    const toRemove = entries.slice(0, entries.length - this.maxEntries);
    for (const [key] of toRemove) {
      this.cache.delete(key);
    }
  }

  /**
   * Clear all entries
   */
  clear(): void {
    this.cache.clear();
    this.metrics = { hits: 0, misses: 0 };
    this.saveToDisk();
  }

  /**
   * Get cache statistics
   */
  getStats(): CacheStats {
    const now = Date.now();
    let expiredCount = 0;
    let oldestEntry: number | null = null;
    let newestEntry: number | null = null;

    for (const entry of this.cache.values()) {
      if (now > entry.expiresAt) {
        expiredCount++;
      }
      if (oldestEntry === null || entry.createdAt < oldestEntry) {
        oldestEntry = entry.createdAt;
      }
      if (newestEntry === null || entry.createdAt > newestEntry) {
        newestEntry = entry.createdAt;
      }
    }

    const total = this.metrics.hits + this.metrics.misses;
    const hitRate = total > 0 ? this.metrics.hits / total : 0;

    // Estimate size based on JSON serialization
    let sizeBytes = 0;
    try {
      sizeBytes = Buffer.byteLength(JSON.stringify(Object.fromEntries(this.cache)));
    } catch {
      sizeBytes = 0;
    }

    return {
      totalEntries: this.cache.size,
      expiredEntries: expiredCount,
      validEntries: this.cache.size - expiredCount,
      hitRate,
      sizeBytes,
      oldestEntry,
      newestEntry,
    };
  }

  /**
   * Close cache and cleanup resources
   */
  close(): void {
    this.stopCleanupTimer();
    this.saveToDisk();
  }

  /**
   * Batch get multiple CVEs
   * @param cveIds - Array of CVE identifiers
   * @returns Map of CVE ID to CVE (only found entries)
   */
  getMultipleCVEs(cveIds: string[]): Map<string, CVE> {
    const result = new Map<string, CVE>();
    for (const cveId of cveIds) {
      const cve = this.getCVE(cveId);
      if (cve) {
        result.set(cveId, cve);
      }
    }
    return result;
  }

  /**
   * Batch set multiple CVEs
   * @param cves - Array of CVEs to cache
   * @param ttl - Optional custom TTL
   */
  setMultipleCVEs(cves: CVE[], ttl?: number): void {
    for (const cve of cves) {
      const key = this.cveKey(cve.id);
      const now = Date.now();
      const entry: CacheEntry<CVE> = {
        data: cve,
        createdAt: now,
        expiresAt: now + (ttl ?? this.defaultTTL),
      };
      this.cache.set(key, entry);
    }
    this.enforceMaxEntries();
    this.saveToDisk();
  }

  /**
   * Touch a cache entry to extend its TTL
   * @param cveId - CVE identifier
   * @param ttl - Optional new TTL
   * @returns true if entry was touched
   */
  touchCVE(cveId: string, ttl?: number): boolean {
    const key = this.cveKey(cveId);
    const entry = this.cache.get(key);
    if (!entry) return false;

    entry.expiresAt = Date.now() + (ttl ?? this.defaultTTL);
    this.saveToDisk();
    return true;
  }
}

/**
 * Create a CVE cache with memory-only storage (no persistence)
 */
export function createMemoryCache(options?: Omit<CVECacheOptions, 'dbPath'>): CVECache {
  // Use /dev/null equivalent - cache in memory only
  const tempPath = `/tmp/musubix-cve-cache-${process.pid}-${Date.now()}.json`;
  return new CVECache({
    ...options,
    dbPath: tempPath,
  });
}

/**
 * Default cache instance (singleton)
 */
let defaultCache: CVECache | null = null;

/**
 * Get or create the default cache instance
 */
export function getDefaultCache(): CVECache {
  if (!defaultCache) {
    defaultCache = new CVECache();
  }
  return defaultCache;
}

/**
 * Close the default cache instance
 */
export function closeDefaultCache(): void {
  if (defaultCache) {
    defaultCache.close();
    defaultCache = null;
  }
}
