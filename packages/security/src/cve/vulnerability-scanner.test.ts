/**
 * @fileoverview Vulnerability Scanner Unit Tests
 * @module @nahisaho/musubix-security/tests/cve/vulnerability-scanner.test
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';
import { VulnerabilityScanner, scanProjectForVulnerabilities } from './vulnerability-scanner.js';

// Mock fetch globally
const mockFetch = vi.fn();
global.fetch = mockFetch;

/**
 * Create mock NVD API response
 */
function createMockNVDResponse(cves: Array<{
  id: string;
  description: string;
  baseScore?: number;
  severity?: string;
  cwes?: string[];
}>) {
  return {
    resultsPerPage: cves.length,
    startIndex: 0,
    totalResults: cves.length,
    format: 'NVD_CVE',
    version: '2.0',
    timestamp: new Date().toISOString(),
    vulnerabilities: cves.map(cve => ({
      cve: {
        id: cve.id,
        sourceIdentifier: 'nvd@nist.gov',
        published: '2024-01-01T00:00:00.000',
        lastModified: '2024-01-02T00:00:00.000',
        vulnStatus: 'ANALYZED',
        descriptions: [
          { lang: 'en', value: cve.description },
        ],
        metrics: cve.baseScore ? {
          cvssMetricV31: [{
            source: 'nvd@nist.gov',
            type: 'Primary',
            cvssData: {
              version: '3.1',
              vectorString: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
              attackVector: 'NETWORK',
              attackComplexity: 'LOW',
              privilegesRequired: 'NONE',
              userInteraction: 'NONE',
              scope: 'UNCHANGED',
              confidentialityImpact: 'HIGH',
              integrityImpact: 'HIGH',
              availabilityImpact: 'HIGH',
              baseScore: cve.baseScore,
              baseSeverity: cve.severity ?? 'HIGH',
            },
          }],
        } : undefined,
        weaknesses: cve.cwes?.map(cwe => ({
          source: 'nvd@nist.gov',
          type: 'Primary',
          description: [{ lang: 'en', value: cwe }],
        })),
        configurations: [{
          nodes: [{
            operator: 'OR',
            negate: false,
            cpeMatch: [{
              vulnerable: true,
              criteria: `cpe:2.3:a:*:${cve.description.split(' ')[0].toLowerCase()}:*:*:*:*:*:node.js:*:*`,
              matchCriteriaId: 'test-id',
            }],
          }],
        }],
        references: [
          { url: `https://example.com/${cve.id}`, source: 'MISC' },
        ],
      },
    })),
  };
}

describe('VulnerabilityScanner', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'vuln-scanner-test-'));
    mockFetch.mockReset();
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  describe('constructor', () => {
    it('should create scanner with default options', () => {
      const scanner = new VulnerabilityScanner();
      expect(scanner).toBeInstanceOf(VulnerabilityScanner);
    });

    it('should accept custom options', () => {
      const scanner = new VulnerabilityScanner({
        includeDevDependencies: true,
        minCvssScore: 7.0,
        maxConcurrent: 10,
      });
      expect(scanner).toBeInstanceOf(VulnerabilityScanner);
    });
  });

  describe('scanDirectory', () => {
    it('should scan project with no vulnerabilities', async () => {
      // Create test project
      const packageJson = {
        name: 'test-project',
        version: '1.0.0',
        dependencies: {
          'safe-package': '1.0.0',
        },
      };
      fs.writeFileSync(
        path.join(tempDir, 'package.json'),
        JSON.stringify(packageJson)
      );

      // Mock NVD response with no matching CVEs
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([]),
      });

      const scanner = new VulnerabilityScanner();
      const result = await scanner.scanDirectory(tempDir);

      expect(result.projectName).toBe('test-project');
      expect(result.totalPackages).toBe(1);
      expect(result.vulnerabilities).toHaveLength(0);
      expect(result.summary.total).toBe(0);
    });

    it('should detect vulnerabilities in dependencies', async () => {
      // Create test project
      const packageJson = {
        name: 'test-project',
        version: '1.0.0',
        dependencies: {
          'express': '4.17.1',
        },
      };
      fs.writeFileSync(
        path.join(tempDir, 'package.json'),
        JSON.stringify(packageJson)
      );

      // Mock NVD response with vulnerability
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([{
          id: 'CVE-2024-12345',
          description: 'Express vulnerability in versions before 4.19.0',
          baseScore: 7.5,
          severity: 'HIGH',
          cwes: ['CWE-79'],
        }]),
      });

      const scanner = new VulnerabilityScanner();
      const result = await scanner.scanDirectory(tempDir);

      expect(result.vulnerabilities.length).toBeGreaterThan(0);
      expect(result.summary.high).toBeGreaterThan(0);
    });

    it('should exclude dev dependencies when configured', async () => {
      const packageJson = {
        name: 'test-project',
        dependencies: { 'express': '4.17.1' },
        devDependencies: { 'jest': '29.0.0' },
      };
      fs.writeFileSync(
        path.join(tempDir, 'package.json'),
        JSON.stringify(packageJson)
      );

      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([]),
      });

      const scanner = new VulnerabilityScanner({
        includeDevDependencies: false,
      });
      const result = await scanner.scanDirectory(tempDir);

      // Should only scan express (1 package)
      expect(result.totalPackages).toBe(1);
    });

    it('should include dev dependencies when configured', async () => {
      const packageJson = {
        name: 'test-project',
        dependencies: { 'express': '4.17.1' },
        devDependencies: { 'jest': '29.0.0' },
      };
      fs.writeFileSync(
        path.join(tempDir, 'package.json'),
        JSON.stringify(packageJson)
      );

      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([]),
      });

      const scanner = new VulnerabilityScanner({
        includeDevDependencies: true,
      });
      const result = await scanner.scanDirectory(tempDir);

      // Should scan both express and jest (2 packages)
      expect(result.totalPackages).toBe(2);
    });

    it('should filter by minimum CVSS score', async () => {
      const packageJson = {
        name: 'test-project',
        dependencies: { 'express': '4.17.1' },
      };
      fs.writeFileSync(
        path.join(tempDir, 'package.json'),
        JSON.stringify(packageJson)
      );

      // Return both high and low severity vulnerabilities
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([
          { id: 'CVE-2024-0001', description: 'Express high severity', baseScore: 9.0, severity: 'CRITICAL' },
          { id: 'CVE-2024-0002', description: 'Express low severity', baseScore: 3.0, severity: 'LOW' },
        ]),
      });

      const scanner = new VulnerabilityScanner({
        minCvssScore: 7.0,
      });
      const result = await scanner.scanDirectory(tempDir);

      // Should only include high severity vulnerability
      const lowSeverity = result.vulnerabilities.filter(v => 
        v.cvssScore !== undefined && v.cvssScore < 7.0
      );
      expect(lowSeverity).toHaveLength(0);
    });

    it('should report progress', async () => {
      const packageJson = {
        name: 'test-project',
        dependencies: { 'express': '4.17.1' },
      };
      fs.writeFileSync(
        path.join(tempDir, 'package.json'),
        JSON.stringify(packageJson)
      );

      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([]),
      });

      const progressUpdates: string[] = [];
      const scanner = new VulnerabilityScanner({
        onProgress: (progress) => progressUpdates.push(progress.phase),
      });

      await scanner.scanDirectory(tempDir);

      expect(progressUpdates).toContain('parsing');
      expect(progressUpdates).toContain('scanning');
      expect(progressUpdates).toContain('complete');
    });

    it('should calculate duration', async () => {
      const packageJson = {
        name: 'test-project',
        dependencies: { 'express': '4.17.1' },
      };
      fs.writeFileSync(
        path.join(tempDir, 'package.json'),
        JSON.stringify(packageJson)
      );

      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([]),
      });

      const scanner = new VulnerabilityScanner();
      const result = await scanner.scanDirectory(tempDir);

      expect(result.durationMs).toBeGreaterThanOrEqual(0);
      expect(result.scanTimestamp).toBeDefined();
    });
  });

  describe('scanPackages', () => {
    it('should scan specific packages', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([{
          id: 'CVE-2024-12345',
          description: 'Lodash vulnerability',
          baseScore: 7.5,
          severity: 'HIGH',
        }]),
      });

      const scanner = new VulnerabilityScanner();
      const vulns = await scanner.scanPackages([
        { name: 'lodash', version: '4.17.20' },
      ]);

      expect(vulns.length).toBeGreaterThanOrEqual(0);
    });

    it('should scan multiple packages', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([]),
      });

      const scanner = new VulnerabilityScanner();
      await scanner.scanPackages([
        { name: 'express', version: '4.18.0' },
        { name: 'lodash', version: '4.17.21' },
      ]);

      // Both packages scanned (fetch called twice)
      expect(mockFetch).toHaveBeenCalledTimes(2);
    });
  });

  describe('summary calculation', () => {
    it('should calculate correct severity summary', async () => {
      const packageJson = {
        name: 'test-project',
        dependencies: { 'test-pkg': '1.0.0' },
      };
      fs.writeFileSync(
        path.join(tempDir, 'package.json'),
        JSON.stringify(packageJson)
      );

      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        json: async () => createMockNVDResponse([
          { id: 'CVE-2024-0001', description: 'test-pkg critical', baseScore: 9.5, severity: 'CRITICAL' },
          { id: 'CVE-2024-0002', description: 'test-pkg high', baseScore: 7.5, severity: 'HIGH' },
          { id: 'CVE-2024-0003', description: 'test-pkg medium', baseScore: 5.5, severity: 'MEDIUM' },
        ]),
      });

      const scanner = new VulnerabilityScanner();
      const result = await scanner.scanDirectory(tempDir);

      expect(result.summary.total).toBe(result.vulnerabilities.length);
    });
  });
});

describe('scanProjectForVulnerabilities', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'vuln-scan-test-'));
    mockFetch.mockReset();
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  it('should provide quick scan function', async () => {
    const packageJson = {
      name: 'test-project',
      dependencies: { 'express': '4.17.1' },
    };
    fs.writeFileSync(
      path.join(tempDir, 'package.json'),
      JSON.stringify(packageJson)
    );

    mockFetch.mockResolvedValue({
      ok: true,
      status: 200,
      json: async () => createMockNVDResponse([]),
    });

    const result = await scanProjectForVulnerabilities(tempDir);

    expect(result.projectName).toBe('test-project');
    expect(result.totalPackages).toBe(1);
  });
});
