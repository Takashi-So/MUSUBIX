/**
 * @fileoverview CVE Cache Unit Tests
 * @module @nahisaho/musubix-security/cve/cve-cache.test
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';
import {
  CVECache,
  createMemoryCache,
  getDefaultCache,
  closeDefaultCache,
} from './cve-cache.js';
import type { CVE } from '../types/cve.js';

/**
 * Create a mock CVE for testing
 */
function createMockCVE(id: string, options?: Partial<CVE>): CVE {
  return {
    id,
    description: `Mock vulnerability ${id}`,
    published: new Date('2024-01-01T00:00:00.000Z'),
    lastModified: new Date('2024-01-02T00:00:00.000Z'),
    cvss: options?.cvss ?? {
      version: '3.1',
      baseScore: 7.5,
      severity: 'HIGH',
      vectorString: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N',
      attackVector: 'NETWORK',
      attackComplexity: 'LOW',
      privilegesRequired: 'NONE',
      userInteraction: 'NONE',
      scope: 'UNCHANGED',
      confidentialityImpact: 'HIGH',
      integrityImpact: 'NONE',
      availabilityImpact: 'NONE',
    },
    cwes: options?.cwes ?? ['CWE-79'],
    references: options?.references ?? [
      { url: `https://example.com/${id}`, source: 'MISC' },
    ],
    affectedProducts: options?.affectedProducts ?? [{
      cpe: 'cpe:2.3:a:test:product:*:*:*:*:*:*:*:*',
      vulnerable: true,
    }],
    status: 'ANALYZED',
    ...options,
  };
}

describe('CVECache', () => {
  let tempDir: string;
  let dbPath: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cve-cache-test-'));
    dbPath = path.join(tempDir, 'test-cache.json');
  });

  afterEach(() => {
    closeDefaultCache();
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  describe('constructor', () => {
    it('should create cache with default options', () => {
      const cache = new CVECache({ dbPath });
      expect(cache).toBeInstanceOf(CVECache);
      cache.close();
    });

    it('should create cache with custom options', () => {
      const cache = new CVECache({
        dbPath,
        defaultTTL: 60000,
        maxEntries: 100,
        autoCleanup: false,
      });
      expect(cache).toBeInstanceOf(CVECache);
      cache.close();
    });

    it('should create storage directory if not exists', () => {
      const nestedPath = path.join(tempDir, 'nested', 'dir', 'cache.json');
      const cache = new CVECache({ dbPath: nestedPath });
      expect(fs.existsSync(path.dirname(nestedPath))).toBe(true);
      cache.close();
    });
  });

  describe('CVE operations', () => {
    let cache: CVECache;

    beforeEach(() => {
      cache = new CVECache({
        dbPath,
        autoCleanup: false,
      });
    });

    afterEach(() => {
      cache.close();
    });

    it('should store and retrieve CVE', () => {
      const cve = createMockCVE('CVE-2024-12345');
      cache.setCVE(cve);

      const retrieved = cache.getCVE('CVE-2024-12345');
      expect(retrieved).toEqual(cve);
    });

    it('should return undefined for non-existent CVE', () => {
      const result = cache.getCVE('CVE-9999-99999');
      expect(result).toBeUndefined();
    });

    it('should check if CVE exists', () => {
      const cve = createMockCVE('CVE-2024-12345');
      cache.setCVE(cve);

      expect(cache.hasCVE('CVE-2024-12345')).toBe(true);
      expect(cache.hasCVE('CVE-9999-99999')).toBe(false);
    });

    it('should delete CVE', () => {
      const cve = createMockCVE('CVE-2024-12345');
      cache.setCVE(cve);

      const deleted = cache.deleteCVE('CVE-2024-12345');
      expect(deleted).toBe(true);
      expect(cache.getCVE('CVE-2024-12345')).toBeUndefined();
    });

    it('should return false when deleting non-existent CVE', () => {
      const deleted = cache.deleteCVE('CVE-9999-99999');
      expect(deleted).toBe(false);
    });

    it('should get CVE metadata', () => {
      const cve = createMockCVE('CVE-2024-12345');
      cache.setCVE(cve);

      const metadata = cache.getCVEMetadata('CVE-2024-12345');
      expect(metadata).toBeDefined();
      expect(metadata?.createdAt).toBeDefined();
      expect(metadata?.expiresAt).toBeGreaterThan(metadata!.createdAt);
    });

    it('should store CVE with custom TTL', () => {
      const cve = createMockCVE('CVE-2024-12345');
      cache.setCVE(cve, 1000); // 1 second TTL

      const metadata = cache.getCVEMetadata('CVE-2024-12345');
      expect(metadata!.expiresAt - metadata!.createdAt).toBe(1000);
    });

    it('should store CVE with ETag', () => {
      const cve = createMockCVE('CVE-2024-12345');
      cache.setCVE(cve, undefined, 'etag-123');

      const metadata = cache.getCVEMetadata('CVE-2024-12345');
      expect(metadata?.etag).toBe('etag-123');
    });
  });

  describe('expiration', () => {
    it('should return undefined for expired CVE', async () => {
      const cache = new CVECache({
        dbPath,
        defaultTTL: 10, // 10ms TTL
        autoCleanup: false,
      });

      const cve = createMockCVE('CVE-2024-12345');
      cache.setCVE(cve);

      // Wait for expiration
      await new Promise(resolve => setTimeout(resolve, 50));

      const retrieved = cache.getCVE('CVE-2024-12345');
      expect(retrieved).toBeUndefined();
      cache.close();
    });

    it('should cleanup expired entries', async () => {
      const cache = new CVECache({
        dbPath,
        defaultTTL: 10,
        autoCleanup: false,
      });

      cache.setCVE(createMockCVE('CVE-2024-0001'));
      cache.setCVE(createMockCVE('CVE-2024-0002'));

      await new Promise(resolve => setTimeout(resolve, 50));

      const removed = cache.cleanup();
      expect(removed).toBe(2);
      cache.close();
    });

    it('should touch CVE to extend TTL', () => {
      const cache = new CVECache({
        dbPath,
        defaultTTL: 1000,
        autoCleanup: false,
      });

      const cve = createMockCVE('CVE-2024-12345');
      cache.setCVE(cve);

      const originalMetadata = cache.getCVEMetadata('CVE-2024-12345');
      
      // Touch with new TTL
      cache.touchCVE('CVE-2024-12345', 5000);
      
      const newMetadata = cache.getCVEMetadata('CVE-2024-12345');
      expect(newMetadata!.expiresAt).toBeGreaterThan(originalMetadata!.expiresAt);
      cache.close();
    });
  });

  describe('CPE operations', () => {
    let cache: CVECache;

    beforeEach(() => {
      cache = new CVECache({
        dbPath,
        autoCleanup: false,
      });
    });

    afterEach(() => {
      cache.close();
    });

    it('should store and retrieve CVEs by CPE', () => {
      const cves = [
        createMockCVE('CVE-2024-0001'),
        createMockCVE('CVE-2024-0002'),
      ];
      const cpeName = 'cpe:2.3:a:expressjs:express:4.17.1:*:*:*:*:node.js:*:*';

      cache.setCVEsByCPE(cpeName, cves);
      const retrieved = cache.getCVEsByCPE(cpeName);

      expect(retrieved).toEqual(cves);
    });

    it('should return undefined for non-cached CPE', () => {
      const result = cache.getCVEsByCPE('cpe:2.3:a:unknown:unknown:*:*:*:*:*:*:*:*');
      expect(result).toBeUndefined();
    });
  });

  describe('keyword operations', () => {
    let cache: CVECache;

    beforeEach(() => {
      cache = new CVECache({
        dbPath,
        autoCleanup: false,
      });
    });

    afterEach(() => {
      cache.close();
    });

    it('should store and retrieve CVEs by keyword', () => {
      const cves = [createMockCVE('CVE-2024-0001')];
      cache.setCVEsByKeyword('express', cves);

      const retrieved = cache.getCVEsByKeyword('express');
      expect(retrieved).toEqual(cves);
    });

    it('should be case-insensitive for keywords', () => {
      const cves = [createMockCVE('CVE-2024-0001')];
      cache.setCVEsByKeyword('EXPRESS', cves);

      const retrieved = cache.getCVEsByKeyword('express');
      expect(retrieved).toEqual(cves);
    });
  });

  describe('batch operations', () => {
    let cache: CVECache;

    beforeEach(() => {
      cache = new CVECache({
        dbPath,
        autoCleanup: false,
      });
    });

    afterEach(() => {
      cache.close();
    });

    it('should get multiple CVEs at once', () => {
      cache.setCVE(createMockCVE('CVE-2024-0001'));
      cache.setCVE(createMockCVE('CVE-2024-0002'));

      const result = cache.getMultipleCVEs([
        'CVE-2024-0001',
        'CVE-2024-0002',
        'CVE-2024-9999', // Non-existent
      ]);

      expect(result.size).toBe(2);
      expect(result.has('CVE-2024-0001')).toBe(true);
      expect(result.has('CVE-2024-0002')).toBe(true);
      expect(result.has('CVE-2024-9999')).toBe(false);
    });

    it('should set multiple CVEs at once', () => {
      const cves = [
        createMockCVE('CVE-2024-0001'),
        createMockCVE('CVE-2024-0002'),
        createMockCVE('CVE-2024-0003'),
      ];

      cache.setMultipleCVEs(cves);

      expect(cache.getCVE('CVE-2024-0001')).toBeDefined();
      expect(cache.getCVE('CVE-2024-0002')).toBeDefined();
      expect(cache.getCVE('CVE-2024-0003')).toBeDefined();
    });
  });

  describe('statistics', () => {
    it('should calculate cache statistics', () => {
      const cache = new CVECache({
        dbPath,
        autoCleanup: false,
      });

      cache.setCVE(createMockCVE('CVE-2024-0001'));
      cache.setCVE(createMockCVE('CVE-2024-0002'));

      // Generate some hits and misses
      cache.getCVE('CVE-2024-0001'); // hit
      cache.getCVE('CVE-2024-9999'); // miss

      const stats = cache.getStats();

      expect(stats.totalEntries).toBe(2);
      expect(stats.validEntries).toBe(2);
      expect(stats.hitRate).toBe(0.5); // 1 hit, 1 miss
      expect(stats.sizeBytes).toBeGreaterThan(0);
      cache.close();
    });
  });

  describe('max entries enforcement', () => {
    it('should enforce max entries limit', () => {
      const cache = new CVECache({
        dbPath,
        maxEntries: 3,
        autoCleanup: false,
      });

      cache.setCVE(createMockCVE('CVE-2024-0001'));
      cache.setCVE(createMockCVE('CVE-2024-0002'));
      cache.setCVE(createMockCVE('CVE-2024-0003'));
      cache.setCVE(createMockCVE('CVE-2024-0004'));

      const stats = cache.getStats();
      expect(stats.totalEntries).toBe(3);
      cache.close();
    });
  });

  describe('persistence', () => {
    it('should persist data to disk', () => {
      const cache1 = new CVECache({
        dbPath,
        autoCleanup: false,
      });

      cache1.setCVE(createMockCVE('CVE-2024-12345'));
      cache1.close();

      // Create new cache instance with same path
      const cache2 = new CVECache({
        dbPath,
        autoCleanup: false,
      });

      const retrieved = cache2.getCVE('CVE-2024-12345');
      expect(retrieved).toBeDefined();
      expect(retrieved?.id).toBe('CVE-2024-12345');
      cache2.close();
    });

    it('should clear all data', () => {
      const cache = new CVECache({
        dbPath,
        autoCleanup: false,
      });

      cache.setCVE(createMockCVE('CVE-2024-0001'));
      cache.setCVE(createMockCVE('CVE-2024-0002'));
      cache.clear();

      expect(cache.getCVE('CVE-2024-0001')).toBeUndefined();
      expect(cache.getCVE('CVE-2024-0002')).toBeUndefined();
      expect(cache.getStats().totalEntries).toBe(0);
      cache.close();
    });
  });
});

describe('createMemoryCache', () => {
  it('should create a memory-only cache', () => {
    const cache = createMemoryCache();
    cache.setCVE(createMockCVE('CVE-2024-12345'));
    expect(cache.getCVE('CVE-2024-12345')).toBeDefined();
    cache.close();
  });
});

describe('getDefaultCache / closeDefaultCache', () => {
  afterEach(() => {
    closeDefaultCache();
  });

  it('should return singleton instance', () => {
    const cache1 = getDefaultCache();
    const cache2 = getDefaultCache();
    expect(cache1).toBe(cache2);
  });

  it('should close default cache', () => {
    const cache = getDefaultCache();
    cache.setCVE(createMockCVE('CVE-2024-12345'));
    closeDefaultCache();

    // Getting default cache again should create new instance
    const newCache = getDefaultCache();
    // Note: Previous data may still be persisted on disk
    expect(newCache).toBeDefined();
  });
});
