/**
 * @fileoverview Tests for vulnerability scanner
 * @module @nahisaho/musubix-security/tests/vulnerability-scanner
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import * as os from 'node:os';
import { VulnerabilityScanner } from '../src/analysis/index.js';

describe('VulnerabilityScanner', () => {
  let scanner: VulnerabilityScanner;
  let tempDir: string;

  beforeEach(async () => {
    scanner = new VulnerabilityScanner();
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'vuln-test-'));
  });

  afterEach(async () => {
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  describe('SQL Injection Detection', () => {
    it('should detect SQL injection via string concatenation', async () => {
      const testFile = path.join(tempDir, 'sql-concat.ts');
      await fs.writeFile(
        testFile,
        `
        function getUser(id: string) {
          db.query("SELECT * FROM users WHERE id = " + id);
        }
        `
      );

      // scanFile returns Vulnerability[], not ScanResult
      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
      expect(Array.isArray(vulnerabilities)).toBe(true);
    });

    it('should detect SQL injection via template literals', async () => {
      const testFile = path.join(tempDir, 'sql-template.ts');
      await fs.writeFile(
        testFile,
        `
        function getUser(id: string) {
          db.query(\`SELECT * FROM users WHERE id = \${id}\`);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });

    it('should not flag parameterized queries', async () => {
      const testFile = path.join(tempDir, 'sql-safe.ts');
      await fs.writeFile(
        testFile,
        `
        function getUser(id: string) {
          db.query("SELECT * FROM users WHERE id = ?", [id]);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const sqlInjections = vulnerabilities.filter(v => v.ruleId === 'sql-injection');
      expect(sqlInjections.length).toBe(0);
    });
  });

  describe('Command Injection Detection', () => {
    it('should detect command injection via exec', async () => {
      const testFile = path.join(tempDir, 'cmd-exec.ts');
      await fs.writeFile(
        testFile,
        `
        import { exec } from 'child_process';
        function runCommand(cmd: string) {
          exec(cmd);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });

    it('should detect command injection via execSync', async () => {
      const testFile = path.join(tempDir, 'cmd-execSync.ts');
      await fs.writeFile(
        testFile,
        `
        import { execSync } from 'child_process';
        function runCommand(cmd: string) {
          execSync(cmd);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });
  });

  describe('Path Traversal Detection', () => {
    it('should detect path traversal via readFile', async () => {
      const testFile = path.join(tempDir, 'path-traversal.ts');
      await fs.writeFile(
        testFile,
        `
        import * as fs from 'fs';
        function readConfig(path: string) {
          fs.readFileSync(path);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });
  });

  describe('XSS Detection', () => {
    it('should detect XSS via innerHTML', async () => {
      const testFile = path.join(tempDir, 'xss-innerhtml.ts');
      await fs.writeFile(
        testFile,
        `
        function render(html: string) {
          element.innerHTML = html;
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });
  });

  describe('Eval Detection', () => {
    it('should detect dangerous eval usage', async () => {
      const testFile = path.join(tempDir, 'eval-dangerous.ts');
      await fs.writeFile(
        testFile,
        `
        function execute(code: string) {
          eval(code);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });

    it('should detect new Function usage', async () => {
      const testFile = path.join(tempDir, 'new-function.ts');
      await fs.writeFile(
        testFile,
        `
        function execute(code: string) {
          new Function(code)();
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });
  });

  describe('Directory Scanning', () => {
    it('should scan all files in directory', async () => {
      await fs.writeFile(
        path.join(tempDir, 'file1.ts'),
        `eval(userInput);`
      );
      await fs.writeFile(
        path.join(tempDir, 'file2.ts'),
        `exec(command);`
      );

      const result = await scanner.scanDirectory(tempDir);
      expect(result.scannedFiles).toBeGreaterThanOrEqual(2);
    });

    it('should respect file extensions', async () => {
      await fs.writeFile(
        path.join(tempDir, 'code.ts'),
        `eval(input);`
      );
      await fs.writeFile(
        path.join(tempDir, 'data.json'),
        `{"key": "value"}`
      );

      const result = await scanner.scanDirectory(tempDir);
      // JSON files may or may not be scanned depending on config
      expect(result.scannedFiles).toBeGreaterThanOrEqual(1);
    });
  });

  describe('ScanResult Structure', () => {
    it('should return proper ScanResult from scanDirectory', async () => {
      await fs.writeFile(
        path.join(tempDir, 'test.ts'),
        `eval(input);`
      );

      const result = await scanner.scanDirectory(tempDir);
      
      expect(result.vulnerabilities).toBeDefined();
      expect(result.scannedFiles).toBeDefined();
      expect(result.skippedFiles).toBeDefined();
      expect(result.duration).toBeDefined();
      expect(result.timestamp).toBeDefined();
      expect(result.summary).toBeDefined();
    });

    it('should include severity breakdown in summary', async () => {
      await fs.writeFile(
        path.join(tempDir, 'test.ts'),
        `
        eval(input);
        exec(cmd);
        db.query("SELECT * FROM " + table);
        `
      );

      const result = await scanner.scanDirectory(tempDir);
      
      expect(result.summary).toBeDefined();
      expect(typeof result.summary.critical).toBe('number');
      expect(typeof result.summary.high).toBe('number');
      expect(typeof result.summary.medium).toBe('number');
      expect(typeof result.summary.low).toBe('number');
      expect(typeof result.summary.info).toBe('number');
    });
  });
});
