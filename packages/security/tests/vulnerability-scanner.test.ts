/**
 * @fileoverview Tests for vulnerability scanner
 * @module @nahisaho/musubix-security/tests/vulnerability-scanner
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import * as os from 'node:os';
import { VulnerabilityScanner } from '../src/analysis/index.js';

describe('VulnerabilityScanner', () => {
  let scanner: VulnerabilityScanner;
  let tempDir: string;

  beforeEach(async () => {
    scanner = new VulnerabilityScanner();
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'vuln-test-'));
  });

  afterEach(async () => {
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  describe('SQL Injection Detection', () => {
    it('should detect SQL injection via string concatenation', async () => {
      const testFile = path.join(tempDir, 'sql-concat.ts');
      await fs.writeFile(
        testFile,
        `
        function getUser(id: string) {
          db.query("SELECT * FROM users WHERE id = " + id);
        }
        `
      );

      // scanFile returns Vulnerability[], not ScanResult
      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
      expect(Array.isArray(vulnerabilities)).toBe(true);
    });

    it('should detect SQL injection via template literals', async () => {
      const testFile = path.join(tempDir, 'sql-template.ts');
      await fs.writeFile(
        testFile,
        `
        function getUser(id: string) {
          db.query(\`SELECT * FROM users WHERE id = \${id}\`);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });

    it('should not flag parameterized queries', async () => {
      const testFile = path.join(tempDir, 'sql-safe.ts');
      await fs.writeFile(
        testFile,
        `
        function getUser(id: string) {
          db.query("SELECT * FROM users WHERE id = ?", [id]);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const sqlInjections = vulnerabilities.filter(v => v.ruleId === 'sql-injection');
      expect(sqlInjections.length).toBe(0);
    });
  });

  describe('Command Injection Detection', () => {
    it('should detect command injection via exec', async () => {
      const testFile = path.join(tempDir, 'cmd-exec.ts');
      await fs.writeFile(
        testFile,
        `
        import { exec } from 'child_process';
        function runCommand(cmd: string) {
          exec(cmd);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });

    it('should detect command injection via execSync', async () => {
      const testFile = path.join(tempDir, 'cmd-execSync.ts');
      await fs.writeFile(
        testFile,
        `
        import { execSync } from 'child_process';
        function runCommand(cmd: string) {
          execSync(cmd);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });
  });

  describe('Path Traversal Detection', () => {
    it('should detect path traversal via readFile', async () => {
      const testFile = path.join(tempDir, 'path-traversal.ts');
      await fs.writeFile(
        testFile,
        `
        import * as fs from 'fs';
        function readConfig(path: string) {
          fs.readFileSync(path);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });
  });

  describe('XSS Detection', () => {
    it('should detect XSS via innerHTML', async () => {
      const testFile = path.join(tempDir, 'xss-innerhtml.ts');
      await fs.writeFile(
        testFile,
        `
        function render(html: string) {
          element.innerHTML = html;
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });
  });

  describe('Eval Detection', () => {
    it('should detect dangerous eval usage', async () => {
      const testFile = path.join(tempDir, 'eval-dangerous.ts');
      await fs.writeFile(
        testFile,
        `
        function execute(code: string) {
          eval(code);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });

    it('should detect new Function usage', async () => {
      const testFile = path.join(tempDir, 'new-function.ts');
      await fs.writeFile(
        testFile,
        `
        function execute(code: string) {
          new Function(code)();
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      expect(vulnerabilities).toBeDefined();
    });
  });

  describe('Directory Scanning', () => {
    it('should scan all files in directory', async () => {
      await fs.writeFile(
        path.join(tempDir, 'file1.ts'),
        `eval(userInput);`
      );
      await fs.writeFile(
        path.join(tempDir, 'file2.ts'),
        `exec(command);`
      );

      const result = await scanner.scanDirectory(tempDir);
      expect(result.scannedFiles).toBeGreaterThanOrEqual(2);
    });

    it('should respect file extensions', async () => {
      await fs.writeFile(
        path.join(tempDir, 'code.ts'),
        `eval(input);`
      );
      await fs.writeFile(
        path.join(tempDir, 'data.json'),
        `{"key": "value"}`
      );

      const result = await scanner.scanDirectory(tempDir);
      // JSON files may or may not be scanned depending on config
      expect(result.scannedFiles).toBeGreaterThanOrEqual(1);
    });
  });

  describe('ScanResult Structure', () => {
    it('should return proper ScanResult from scanDirectory', async () => {
      await fs.writeFile(
        path.join(tempDir, 'test.ts'),
        `eval(input);`
      );

      const result = await scanner.scanDirectory(tempDir);
      
      expect(result.vulnerabilities).toBeDefined();
      expect(result.scannedFiles).toBeDefined();
      expect(result.skippedFiles).toBeDefined();
      expect(result.duration).toBeDefined();
      expect(result.timestamp).toBeDefined();
      expect(result.summary).toBeDefined();
    });

    it('should include severity breakdown in summary', async () => {
      await fs.writeFile(
        path.join(tempDir, 'test.ts'),
        `
        eval(input);
        exec(cmd);
        db.query("SELECT * FROM " + table);
        `
      );

      const result = await scanner.scanDirectory(tempDir);
      
      expect(result.summary).toBeDefined();
      expect(typeof result.summary.critical).toBe('number');
      expect(typeof result.summary.high).toBe('number');
      expect(typeof result.summary.medium).toBe('number');
      expect(typeof result.summary.low).toBe('number');
      expect(typeof result.summary.info).toBe('number');
    });
  });

  // ============================================================================
  // New Vulnerability Detectors (CWE-918, CWE-502, CWE-611, CWE-90, CWE-1333, CWE-362)
  // ============================================================================

  describe('SSRF Detection (CWE-918)', () => {
    it('should detect SSRF via fetch with dynamic URL', async () => {
      const testFile = path.join(tempDir, 'ssrf-fetch.ts');
      await fs.writeFile(
        testFile,
        `
        async function fetchUrl(url: string) {
          const response = await fetch(url);
          return response.json();
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const ssrf = vulnerabilities.filter(v => v.type === 'ssrf');
      expect(ssrf.length).toBeGreaterThan(0);
      expect(ssrf[0].cwes).toContain('CWE-918');
    });

    it('should detect SSRF via axios with template URL', async () => {
      const testFile = path.join(tempDir, 'ssrf-axios.ts');
      await fs.writeFile(
        testFile,
        `
        import axios from 'axios';
        async function fetchData(host: string) {
          return axios.get(\`https://\${host}/api/data\`);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const ssrf = vulnerabilities.filter(v => v.type === 'ssrf');
      expect(ssrf.length).toBeGreaterThan(0);
    });
  });

  describe('Insecure Deserialization Detection (CWE-502)', () => {
    it('should detect unsafe YAML parsing', async () => {
      const testFile = path.join(tempDir, 'deser-yaml.ts');
      await fs.writeFile(
        testFile,
        `
        import * as yaml from 'js-yaml';
        function parseConfig(content: string) {
          const config = yaml.load(content);
          return config;
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const deser = vulnerabilities.filter(v => v.type === 'insecure-deserialization');
      expect(deser.length).toBeGreaterThan(0);
      expect(deser[0].cwes).toContain('CWE-502');
    });

    it('should detect JSON.parse with user input', async () => {
      const testFile = path.join(tempDir, 'deser-json.ts');
      await fs.writeFile(
        testFile,
        `
        function parseUserInput(data: string) {
          return JSON.parse(data);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const deser = vulnerabilities.filter(v => v.type === 'insecure-deserialization');
      // JSON.parse is lower severity but should still be flagged
      expect(deser.length).toBeGreaterThanOrEqual(0); // May or may not flag depending on context
    });
  });

  describe('XXE Detection (CWE-611)', () => {
    it('should detect xml2js parsing without secure options', async () => {
      const testFile = path.join(tempDir, 'xxe-xml2js.ts');
      await fs.writeFile(
        testFile,
        `
        import { parseString } from 'xml2js';
        function parseXml(content: string) {
          parseString(content, (err, result) => {
            console.log(result);
          });
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const xxe = vulnerabilities.filter(v => v.type === 'xxe');
      expect(xxe.length).toBeGreaterThan(0);
      expect(xxe[0].cwes).toContain('CWE-611');
    });

    it('should detect DOMParser instantiation', async () => {
      const testFile = path.join(tempDir, 'xxe-domparser.ts');
      await fs.writeFile(
        testFile,
        `
        function parseXml(xmlString: string) {
          const parser = new DOMParser();
          return parser.parseFromString(xmlString, 'text/xml');
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const xxe = vulnerabilities.filter(v => v.type === 'xxe');
      expect(xxe.length).toBeGreaterThan(0);
    });
  });

  describe('LDAP Injection Detection (CWE-90)', () => {
    it('should detect LDAP filter with string concatenation', async () => {
      const testFile = path.join(tempDir, 'ldap-injection.ts');
      await fs.writeFile(
        testFile,
        `
        function searchUser(username: string) {
          const filter = "(&(objectClass=user)(uid=" + username + "))";
          ldapClient.search(baseDN, { filter });
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const ldap = vulnerabilities.filter(v => v.type === 'ldap-injection');
      expect(ldap.length).toBeGreaterThan(0);
      expect(ldap[0].cwes).toContain('CWE-90');
    });

    it('should detect LDAP search with template filter', async () => {
      const testFile = path.join(tempDir, 'ldap-template.ts');
      await fs.writeFile(
        testFile,
        `
        function findUser(uid: string) {
          const filter = \`(&(objectClass=user)(uid=\${uid}))\`;
          ldapClient.search(\`ou=users,dc=example,dc=com\`, { filter: filter });
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const ldap = vulnerabilities.filter(v => v.type === 'ldap-injection');
      expect(ldap.length).toBeGreaterThan(0);
    });
  });

  describe('ReDoS Detection (CWE-1333)', () => {
    it('should detect catastrophic backtracking pattern (.*)+', async () => {
      const testFile = path.join(tempDir, 'redos-nested.ts');
      await fs.writeFile(
        testFile,
        `
        const pattern = /(.*)+/;
        function match(input: string) {
          return pattern.test(input);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const redos = vulnerabilities.filter(v => v.type === 'redos');
      expect(redos.length).toBeGreaterThan(0);
      expect(redos[0].cwes).toContain('CWE-1333');
    });

    it('should detect nested quantifiers (a+)+', async () => {
      const testFile = path.join(tempDir, 'redos-quantifiers.ts');
      await fs.writeFile(
        testFile,
        `
        const regex = new RegExp('(a+)+b');
        function validate(input: string) {
          return regex.test(input);
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const redos = vulnerabilities.filter(v => v.type === 'redos');
      expect(redos.length).toBeGreaterThan(0);
    });

    it('should detect (.+)* pattern', async () => {
      const testFile = path.join(tempDir, 'redos-plus-star.ts');
      await fs.writeFile(
        testFile,
        `
        const emailRegex = /^([a-zA-Z0-9]+)*@example\\.com$/;
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const redos = vulnerabilities.filter(v => v.type === 'redos');
      expect(redos.length).toBeGreaterThan(0);
    });
  });

  describe('Race Condition Detection (CWE-362)', () => {
    it('should detect TOCTOU pattern (exists then read)', async () => {
      const testFile = path.join(tempDir, 'race-toctou.ts');
      await fs.writeFile(
        testFile,
        `
        import * as fs from 'fs';
        function readIfExists(filePath: string) {
          if (fs.existsSync(filePath)) {
            return fs.readFileSync(filePath);
          }
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const race = vulnerabilities.filter(v => v.type === 'race-condition');
      expect(race.length).toBeGreaterThan(0);
      expect(race[0].cwes).toContain('CWE-362');
    });

    it('should detect shared state modification in async context', async () => {
      const testFile = path.join(tempDir, 'race-async.ts');
      await fs.writeFile(
        testFile,
        `
        async function updateGlobal(value: number) {
          await someAsyncOperation();
          global.counter = value;
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const race = vulnerabilities.filter(v => v.type === 'race-condition');
      expect(race.length).toBeGreaterThan(0);
    });

    it('should detect concurrent file operations in Promise.all', async () => {
      const testFile = path.join(tempDir, 'race-promiseall.ts');
      await fs.writeFile(
        testFile,
        `
        import * as fs from 'fs/promises';
        async function updateFiles(files: string[]) {
          await Promise.all(files.map(f => fs.writeFile(f, 'data')));
        }
        `
      );

      const vulnerabilities = scanner.scanFile(testFile);
      const race = vulnerabilities.filter(v => v.type === 'race-condition');
      expect(race.length).toBeGreaterThan(0);
    });
  });

  describe('Rule Count', () => {
    it('should have 12 built-in security rules', () => {
      expect(scanner.getRuleCount()).toBe(12);
    });

    it('should include all new rule IDs', () => {
      const ruleIds = scanner.getRuleIds();
      expect(ruleIds).toContain('SEC-007'); // SSRF
      expect(ruleIds).toContain('SEC-008'); // Insecure Deserialization
      expect(ruleIds).toContain('SEC-009'); // XXE
      expect(ruleIds).toContain('SEC-010'); // LDAP Injection
      expect(ruleIds).toContain('SEC-011'); // ReDoS
      expect(ruleIds).toContain('SEC-012'); // Race Condition
    });
  });
});
