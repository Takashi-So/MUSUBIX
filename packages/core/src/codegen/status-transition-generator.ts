/**
 * Status Transition Generator
 *
 * Generates status transition code based on BP-DESIGN-001 pattern.
 * Creates type-safe status enums, transition maps, and validation functions.
 *
 * @module codegen/status-transition-generator
 * @since v3.1.0
 */

/**
 * Status transition definition
 */
export interface StatusTransition {
  /** Source status */
  from: string;
  /** Target status */
  to: string;
  /** Optional condition description */
  condition?: string;
  /** Optional action description */
  action?: string;
}

/**
 * Status definition
 */
export interface StatusDefinition {
  /** Status name (e.g., 'draft', 'active') */
  name: string;
  /** Display label */
  label?: string;
  /** Description */
  description?: string;
  /** Is this an initial status? */
  isInitial?: boolean;
  /** Is this a terminal status? */
  isTerminal?: boolean;
}

/**
 * Status machine specification
 */
export interface StatusMachineSpec {
  /** Name of the status machine (e.g., 'Order', 'Task') */
  name: string;
  /** Description */
  description?: string;
  /** Related requirement ID */
  requirementId?: string;
  /** List of statuses */
  statuses: StatusDefinition[];
  /** List of valid transitions */
  transitions: StatusTransition[];
}

/**
 * Generator options
 */
export interface StatusGeneratorOptions {
  /** Use string literal union (default: true) or enum */
  useUnionType?: boolean;
  /** Generate transition validation function (default: true) */
  generateValidator?: boolean;
  /** Generate transition map constant (default: true) */
  generateTransitionMap?: boolean;
  /** Generate JSDoc comments (default: true) */
  includeJSDoc?: boolean;
  /** Generate helper functions (default: true) */
  generateHelpers?: boolean;
}

/**
 * Generation result
 */
export interface StatusGenerationResult {
  /** Generated TypeScript code */
  code: string;
  /** File name suggestion */
  fileName: string;
  /** Status count */
  statusCount: number;
  /** Transition count */
  transitionCount: number;
  /** Initial status name */
  initialStatus?: string;
  /** Terminal status names */
  terminalStatuses: string[];
}

/**
 * Default generator options
 */
const DEFAULT_OPTIONS: Required<StatusGeneratorOptions> = {
  useUnionType: true,
  generateValidator: true,
  generateTransitionMap: true,
  includeJSDoc: true,
  generateHelpers: true,
};

/**
 * Status Transition Generator
 *
 * Generates type-safe status transition code following BP-DESIGN-001 pattern.
 */
export class StatusTransitionGenerator {
  private options: Required<StatusGeneratorOptions>;

  constructor(options?: StatusGeneratorOptions) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  /**
   * Generate status transition code
   */
  generate(spec: StatusMachineSpec): StatusGenerationResult {
    const lines: string[] = [];
    const name = spec.name;
    const statusTypeName = `${name}Status`;

    // JSDoc header
    if (this.options.includeJSDoc) {
      lines.push('/**');
      lines.push(` * ${name} Status Transitions`);
      if (spec.description) {
        lines.push(` * `);
        lines.push(` * ${spec.description}`);
      }
      if (spec.requirementId) {
        lines.push(` * `);
        lines.push(` * @requirement ${spec.requirementId}`);
      }
      lines.push(` * @generated by MUSUBIX StatusTransitionGenerator`);
      lines.push(' */');
      lines.push('');
    }

    // Status type
    if (this.options.useUnionType) {
      lines.push(...this.generateUnionType(statusTypeName, spec.statuses));
    } else {
      lines.push(...this.generateEnum(statusTypeName, spec.statuses));
    }
    lines.push('');

    // Status values array
    lines.push(...this.generateStatusValues(statusTypeName, spec.statuses));
    lines.push('');

    // Transition map
    if (this.options.generateTransitionMap) {
      lines.push(...this.generateTransitionMap(statusTypeName, spec));
      lines.push('');
    }

    // Validator
    if (this.options.generateValidator) {
      lines.push(...this.generateValidator(statusTypeName, name));
      lines.push('');
    }

    // Helper functions
    if (this.options.generateHelpers) {
      lines.push(...this.generateHelpers(statusTypeName, name, spec));
    }

    const initialStatus = spec.statuses.find((s) => s.isInitial);
    const terminalStatuses = spec.statuses.filter((s) => s.isTerminal);

    return {
      code: lines.join('\n'),
      fileName: `${this.toKebabCase(name)}-status.ts`,
      statusCount: spec.statuses.length,
      transitionCount: spec.transitions.length,
      initialStatus: initialStatus?.name,
      terminalStatuses: terminalStatuses.map((s) => s.name),
    };
  }

  /**
   * Generate union type definition
   */
  private generateUnionType(typeName: string, statuses: StatusDefinition[]): string[] {
    const lines: string[] = [];

    if (this.options.includeJSDoc) {
      lines.push('/**');
      lines.push(` * ${typeName} - Valid status values`);
      lines.push(' */');
    }

    const values = statuses.map((s) => `'${s.name}'`).join(' | ');
    lines.push(`export type ${typeName} = ${values};`);

    return lines;
  }

  /**
   * Generate enum definition
   */
  private generateEnum(typeName: string, statuses: StatusDefinition[]): string[] {
    const lines: string[] = [];

    if (this.options.includeJSDoc) {
      lines.push('/**');
      lines.push(` * ${typeName} - Valid status values`);
      lines.push(' */');
    }

    lines.push(`export enum ${typeName} {`);
    for (const status of statuses) {
      const enumName = this.toPascalCase(status.name);
      if (this.options.includeJSDoc && status.description) {
        lines.push(`  /** ${status.description} */`);
      }
      lines.push(`  ${enumName} = '${status.name}',`);
    }
    lines.push('}');

    return lines;
  }

  /**
   * Generate status values array
   */
  private generateStatusValues(typeName: string, statuses: StatusDefinition[]): string[] {
    const lines: string[] = [];

    if (this.options.includeJSDoc) {
      lines.push('/**');
      lines.push(` * All valid ${typeName} values`);
      lines.push(' */');
    }

    const values = statuses.map((s) => `'${s.name}'`).join(', ');
    lines.push(`export const ${typeName.charAt(0).toLowerCase() + typeName.slice(1)}Values: readonly ${typeName}[] = [${values}] as const;`);

    return lines;
  }

  /**
   * Generate transition map (BP-DESIGN-001 pattern)
   */
  private generateTransitionMap(typeName: string, spec: StatusMachineSpec): string[] {
    const lines: string[] = [];

    if (this.options.includeJSDoc) {
      lines.push('/**');
      lines.push(` * Valid status transitions map`);
      lines.push(` * `);
      lines.push(` * @pattern BP-DESIGN-001 Status Transition Map`);
      lines.push(' */');
    }

    lines.push(`export const valid${spec.name}Transitions: Record<${typeName}, ${typeName}[]> = {`);

    for (const status of spec.statuses) {
      const validTargets = spec.transitions
        .filter((t) => t.from === status.name)
        .map((t) => `'${t.to}'`);

      lines.push(`  '${status.name}': [${validTargets.join(', ')}],`);
    }

    lines.push('};');

    return lines;
  }

  /**
   * Generate validator function
   */
  private generateValidator(typeName: string, name: string): string[] {
    const lines: string[] = [];

    if (this.options.includeJSDoc) {
      lines.push('/**');
      lines.push(` * Check if a status transition is valid`);
      lines.push(` * `);
      lines.push(` * @param from - Current status`);
      lines.push(` * @param to - Target status`);
      lines.push(` * @returns true if the transition is valid`);
      lines.push(' */');
    }

    lines.push(`export function canTransition${name}Status(from: ${typeName}, to: ${typeName}): boolean {`);
    lines.push(`  return valid${name}Transitions[from].includes(to);`);
    lines.push('}');

    return lines;
  }

  /**
   * Generate helper functions
   */
  private generateHelpers(
    typeName: string,
    name: string,
    spec: StatusMachineSpec
  ): string[] {
    const lines: string[] = [];
    const initialStatus = spec.statuses.find((s) => s.isInitial);
    const terminalStatuses = spec.statuses.filter((s) => s.isTerminal);

    // getInitialStatus
    if (initialStatus) {
      if (this.options.includeJSDoc) {
        lines.push('/**');
        lines.push(` * Get the initial status for ${name}`);
        lines.push(' */');
      }
      lines.push(`export function getInitial${name}Status(): ${typeName} {`);
      lines.push(`  return '${initialStatus.name}';`);
      lines.push('}');
      lines.push('');
    }

    // isTerminalStatus
    if (terminalStatuses.length > 0) {
      if (this.options.includeJSDoc) {
        lines.push('/**');
        lines.push(` * Check if a status is terminal (no further transitions)`);
        lines.push(' */');
      }
      const terminalList = terminalStatuses.map((s) => `'${s.name}'`).join(', ');
      lines.push(`export function isTerminal${name}Status(status: ${typeName}): boolean {`);
      lines.push(`  const terminalStatuses: ${typeName}[] = [${terminalList}];`);
      lines.push(`  return terminalStatuses.includes(status);`);
      lines.push('}');
      lines.push('');
    }

    // getNextStatuses
    if (this.options.includeJSDoc) {
      lines.push('/**');
      lines.push(` * Get all valid next statuses from the current status`);
      lines.push(' */');
    }
    lines.push(`export function getNext${name}Statuses(current: ${typeName}): ${typeName}[] {`);
    lines.push(`  return valid${name}Transitions[current];`);
    lines.push('}');
    lines.push('');

    // assertTransition - only if validator is also generated
    if (this.options.generateValidator) {
      if (this.options.includeJSDoc) {
        lines.push('/**');
        lines.push(` * Assert that a status transition is valid`);
        lines.push(` * @throws Error if the transition is not valid`);
        lines.push(' */');
      }
      lines.push(`export function assertValid${name}Transition(from: ${typeName}, to: ${typeName}): void {`);
      lines.push(`  if (!canTransition${name}Status(from, to)) {`);
      lines.push(`    throw new Error(\`Invalid ${name} status transition: \${from} -> \${to}\`);`);
      lines.push(`  }`);
      lines.push('}');
    }

    return lines;
  }

  /**
   * Convert PascalCase to kebab-case
   */
  private toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')
      .toLowerCase();
  }

  /**
   * Convert string to PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .split(/[-_\s]+/)
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}

/**
 * Generate status transition code (convenience function)
 */
export function generateStatusTransitions(
  spec: StatusMachineSpec,
  options?: StatusGeneratorOptions
): StatusGenerationResult {
  const generator = new StatusTransitionGenerator(options);
  return generator.generate(spec);
}

/**
 * Parse status machine from simple text format
 *
 * Format:
 * Name: Order
 * Statuses: draft, pending, confirmed, shipped, delivered, cancelled
 * Initial: draft
 * Terminal: delivered, cancelled
 * Transitions:
 *   draft -> pending
 *   pending -> confirmed, cancelled
 *   confirmed -> shipped, cancelled
 *   shipped -> delivered
 */
export function parseStatusMachineSpec(text: string): StatusMachineSpec {
  const lines = text.split('\n').map((l) => l.trim()).filter((l) => l);
  const spec: StatusMachineSpec = {
    name: '',
    statuses: [],
    transitions: [],
  };

  let initialStatus: string | undefined;
  let terminalStatuses: string[] = [];
  let inTransitions = false;

  for (const line of lines) {
    if (line.toLowerCase().startsWith('name:')) {
      spec.name = line.slice(5).trim();
    } else if (line.toLowerCase().startsWith('description:')) {
      spec.description = line.slice(12).trim();
    } else if (line.toLowerCase().startsWith('requirement:')) {
      spec.requirementId = line.slice(12).trim();
    } else if (line.toLowerCase().startsWith('statuses:')) {
      const statusNames = line.slice(9).split(',').map((s) => s.trim());
      spec.statuses = statusNames.map((name) => ({ name }));
    } else if (line.toLowerCase().startsWith('initial:')) {
      initialStatus = line.slice(8).trim();
    } else if (line.toLowerCase().startsWith('terminal:')) {
      terminalStatuses = line.slice(9).split(',').map((s) => s.trim());
    } else if (line.toLowerCase().startsWith('transitions:')) {
      inTransitions = true;
    } else if (inTransitions && line.includes('->')) {
      const [from, toList] = line.split('->').map((s) => s.trim());
      const targets = toList.split(',').map((s) => s.trim());
      for (const to of targets) {
        spec.transitions.push({ from, to });
      }
    }
  }

  // Apply initial and terminal flags
  for (const status of spec.statuses) {
    if (status.name === initialStatus) {
      status.isInitial = true;
    }
    if (terminalStatuses.includes(status.name)) {
      status.isTerminal = true;
    }
  }

  return spec;
}
