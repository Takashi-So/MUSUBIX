/**
 * @fileoverview Lean file generator for creating .lean source files
 * @module @nahisaho/musubix-lean/infrastructure
 * @traceability REQ-LEAN-CORE-003
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import type { LeanTheorem, LeanProof, LeanConfig } from '../types.js';
import { LeanFileGenerationError } from '../errors.js';

/**
 * Generated file information
 */
export interface GeneratedFile {
  path: string;
  content: string;
  theoremCount: number;
}

/**
 * File generation options
 */
export interface GenerationOptions {
  outputDir: string;
  fileName?: string;
  includeImports?: boolean;
  includeProofs?: boolean;
  modulePrefix?: string;
}

/**
 * Standard Lean 4 imports
 */
const STANDARD_IMPORTS = `import Lean
import Mathlib.Tactic`;

/**
 * MUSUBIX namespace header
 */
const MUSUBIX_HEADER = `/-!
# MUSUBIX Generated Theorems

This file was automatically generated by @nahisaho/musubix-lean.
Do not edit manually unless you know what you're doing.

## Requirements Traceability
Each theorem maps to a specific EARS requirement from the system specification.
-/`;

/**
 * Generates Lean source files from theorems
 * @traceability REQ-LEAN-CORE-003
 */
export class LeanFileGenerator {
  private projectPath: string;
  private timeout: number;

  constructor(config: Partial<LeanConfig> = {}) {
    this.projectPath = config.projectPath ?? process.cwd();
    this.timeout = config.timeout ?? 30000;
  }

  /**
   * Generate a Lean file from theorems
   * @traceability REQ-LEAN-CORE-003
   */
  async generate(
    theorems: LeanTheorem[],
    options: GenerationOptions
  ): Promise<GeneratedFile> {
    const { outputDir, fileName, includeImports, includeProofs, modulePrefix } = options;

    // Build file content
    const content = this.buildFileContent(theorems, {
      includeImports: includeImports ?? true,
      includeProofs: includeProofs ?? true,
      modulePrefix,
    });

    // Determine file name
    const finalFileName = fileName ?? this.generateFileName(theorems);
    const filePath = path.join(outputDir, finalFileName);

    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });

    // Write file
    try {
      await fs.writeFile(filePath, content, 'utf-8');
    } catch (error) {
      throw new LeanFileGenerationError(
        filePath,
        error instanceof Error ? error.message : String(error)
      );
    }

    return {
      path: filePath,
      content,
      theoremCount: theorems.length,
    };
  }

  /**
   * Generate multiple Lean files (one per requirement category)
   */
  async generateMultiple(
    theorems: LeanTheorem[],
    outputDir: string
  ): Promise<GeneratedFile[]> {
    // Group theorems by requirement prefix
    const groups = new Map<string, LeanTheorem[]>();

    for (const theorem of theorems) {
      // Extract category from requirement ID (e.g., REQ-LEAN-CORE-001 -> CORE)
      const match = theorem.requirementId?.match(/REQ-\w+-(\w+)-/);
      const category = match?.[1] ?? 'General';

      if (!groups.has(category)) {
        groups.set(category, []);
      }
      groups.get(category)!.push(theorem);
    }

    // Generate file for each group
    const files: GeneratedFile[] = [];

    for (const [category, categoryTheorems] of groups) {
      const file = await this.generate(categoryTheorems, {
        outputDir,
        fileName: `${category}.lean`,
        modulePrefix: `MUSUBIX.${category}`,
      });
      files.push(file);
    }

    return files;
  }

  /**
   * Build Lean file content from theorems
   */
  private buildFileContent(
    theorems: LeanTheorem[],
    options: {
      includeImports?: boolean;
      includeProofs?: boolean;
      modulePrefix?: string;
    }
  ): string {
    const lines: string[] = [];

    // Header
    lines.push(MUSUBIX_HEADER);
    lines.push('');

    // Imports
    if (options.includeImports !== false) {
      lines.push(STANDARD_IMPORTS);
      lines.push('');
    }

    // Namespace
    const namespace = options.modulePrefix ?? 'MUSUBIX.Generated';
    lines.push(`namespace ${namespace}`);
    lines.push('');

    // Theorems
    for (const theorem of theorems) {
      lines.push(this.formatTheorem(theorem, options.includeProofs ?? true));
      lines.push('');
    }

    // Close namespace
    lines.push(`end ${namespace}`);
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Format a single theorem as Lean code
   */
  private formatTheorem(theorem: LeanTheorem, includeProof: boolean): string {
    const lines: string[] = [];

    // Doc comment
    if (theorem.description) {
      lines.push(`/-- ${theorem.description}`);
      if (theorem.requirementId) {
        lines.push(`    @traceability ${theorem.requirementId}`);
      }
      lines.push('-/');
    }

    // Theorem declaration
    const proofCode = includeProof && theorem.proof
      ? theorem.proof.leanCode
      : 'sorry';

    lines.push(`theorem ${theorem.name} : ${theorem.statement} := by`);
    lines.push(`  ${proofCode}`);

    return lines.join('\n');
  }

  /**
   * Generate a file name from theorems
   */
  private generateFileName(theorems: LeanTheorem[]): string {
    if (theorems.length === 0) {
      return 'Empty.lean';
    }

    // Use first theorem's requirement ID if available
    const first = theorems[0];
    if (first.requirementId) {
      const match = first.requirementId.match(/REQ-(\w+)/);
      if (match) {
        return `${match[1]}.lean`;
      }
    }

    // Default
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    return `Generated_${timestamp}.lean`;
  }

  /**
   * Combine a proof with a theorem
   */
  combineTheoremWithProof(theorem: LeanTheorem, proof: LeanProof): LeanTheorem {
    return {
      ...theorem,
      proof,
    };
  }

  /**
   * Validate generated Lean syntax (basic check)
   */
  validateSyntax(content: string): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for balanced delimiters
    const openParens = (content.match(/\(/g) || []).length;
    const closeParens = (content.match(/\)/g) || []).length;
    if (openParens !== closeParens) {
      errors.push(`Unbalanced parentheses: ${openParens} open, ${closeParens} close`);
    }

    const openBraces = (content.match(/\{/g) || []).length;
    const closeBraces = (content.match(/\}/g) || []).length;
    if (openBraces !== closeBraces) {
      errors.push(`Unbalanced braces: ${openBraces} open, ${closeBraces} close`);
    }

    const openBrackets = (content.match(/\[/g) || []).length;
    const closeBrackets = (content.match(/\]/g) || []).length;
    if (openBrackets !== closeBrackets) {
      errors.push(`Unbalanced brackets: ${openBrackets} open, ${closeBrackets} close`);
    }

    // Check for common errors
    if (content.includes(':= by\n\n')) {
      errors.push('Empty proof block detected');
    }

    // Check for namespace balance
    const namespaceCount = (content.match(/\bnamespace\s+\w+/g) || []).length;
    const endCount = (content.match(/\bend\s+\w+/g) || []).length;
    if (namespaceCount !== endCount) {
      errors.push(`Unbalanced namespace: ${namespaceCount} namespace, ${endCount} end`);
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Get Lean file template
   */
  getTemplate(templateType: 'basic' | 'mathlib' | 'custom'): string {
    switch (templateType) {
      case 'basic':
        return `import Lean

namespace MyProject

-- Your theorems here

end MyProject
`;

      case 'mathlib':
        return `import Mathlib.Tactic
import Mathlib.Data.Nat.Basic
import Mathlib.Data.List.Basic

namespace MyProject

open Nat List

-- Your theorems here

end MyProject
`;

      case 'custom':
        return `/-!
# Custom MUSUBIX Project

Add your imports and theorems below.
-/

import Lean

namespace MUSUBIX

-- Requirements-driven theorems

end MUSUBIX
`;

      default:
        return '';
    }
  }
}
