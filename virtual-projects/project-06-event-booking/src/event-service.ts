/**
 * EventService
 * イベント作成・検索・管理
 *
 * @generated by MUSUBIX from C4 design
 * @module event-service
 * @designElement DES-EVENT-001
 * @traces REQ-EVENT-001, REQ-EVENT-002, REQ-EVENT-003, REQ-EVENT-004
 */

// ============================================================
// Types & Interfaces
// ============================================================

export interface Event {
  id: string;
  title: string;
  description: string;
  category: EventCategory;
  organizerId: string;
  venue: Venue;
  startDate: Date;
  endDate: Date;
  capacity: number;
  ticketsSold: number;
  status: EventStatus;
  ticketTypes: TicketType[];
  images: string[];
  tags: string[];
  isSeated: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export type EventCategory =
  | 'concert'
  | 'seminar'
  | 'workshop'
  | 'conference'
  | 'festival'
  | 'sports'
  | 'theater'
  | 'other';

export type EventStatus = 'draft' | 'published' | 'sold-out' | 'cancelled' | 'completed';

export interface Venue {
  name: string;
  address: string;
  city: string;
  country: string;
  postalCode: string;
  coordinates: { lat: number; lng: number };
  capacity: number;
}

export interface TicketType {
  id: string;
  name: string;
  description: string;
  price: number;
  quantity: number;
  sold: number;
  maxPerOrder: number;
  salesStart: Date;
  salesEnd: Date;
  isActive: boolean;
}

export interface CreateEventInput {
  title: string;
  description: string;
  category: EventCategory;
  organizerId: string;
  venue: Venue;
  startDate: Date;
  endDate: Date;
  capacity: number;
  ticketTypes: Omit<TicketType, 'id' | 'sold'>[];
  images?: string[];
  tags?: string[];
  isSeated?: boolean;
}

export interface UpdateEventInput {
  title?: string;
  description?: string;
  category?: EventCategory;
  venue?: Venue;
  startDate?: Date;
  endDate?: Date;
  capacity?: number;
  images?: string[];
  tags?: string[];
}

export interface EventSearchOptions {
  keyword?: string;
  category?: EventCategory;
  dateFrom?: Date;
  dateTo?: Date;
  city?: string;
  priceMin?: number;
  priceMax?: number;
  status?: EventStatus;
  organizerId?: string;
  limit?: number;
  offset?: number;
}

export interface EventSearchResult {
  events: Event[];
  total: number;
  limit: number;
  offset: number;
}

/**
 * EventService interface
 * @implements REQ-EVENT-001, REQ-EVENT-002, REQ-EVENT-003, REQ-EVENT-004
 */
export interface IEventService {
  createEvent(data: CreateEventInput): Promise<Event>;
  getEvent(id: string): Promise<Event | null>;
  searchEvents(options: EventSearchOptions): Promise<EventSearchResult>;
  updateEvent(id: string, data: UpdateEventInput): Promise<Event>;
  cancelEvent(id: string, reason: string): Promise<Event>;
  publishEvent(id: string): Promise<Event>;
  getEventsByOrganizer(organizerId: string): Promise<Event[]>;
  updateTicketAvailability(eventId: string, ticketTypeId: string, soldCount: number): Promise<Event>;
  addTicketType(eventId: string, ticketType: Omit<TicketType, 'id' | 'sold'>): Promise<Event>;
}

export interface IEventRepository {
  save(event: Event): Promise<Event>;
  findById(id: string): Promise<Event | null>;
  findByOrganizer(organizerId: string): Promise<Event[]>;
  search(options: EventSearchOptions): Promise<{ events: Event[]; total: number }>;
  update(id: string, data: Partial<Event>): Promise<Event>;
  delete(id: string): Promise<boolean>;
}

// ============================================================
// Implementation
// ============================================================

export class EventService implements IEventService {
  constructor(private repository: IEventRepository) {}

  async createEvent(data: CreateEventInput): Promise<Event> {
    const ticketTypes: TicketType[] = data.ticketTypes.map((tt, index) => ({
      ...tt,
      id: `TT-${Date.now()}-${index}`,
      sold: 0,
    }));

    const event: Event = {
      id: `EVT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      title: data.title,
      description: data.description,
      category: data.category,
      organizerId: data.organizerId,
      venue: data.venue,
      startDate: data.startDate,
      endDate: data.endDate,
      capacity: data.capacity,
      ticketsSold: 0,
      status: 'draft',
      ticketTypes,
      images: data.images || [],
      tags: data.tags || [],
      isSeated: data.isSeated || false,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    return this.repository.save(event);
  }

  async getEvent(id: string): Promise<Event | null> {
    return this.repository.findById(id);
  }

  async searchEvents(options: EventSearchOptions): Promise<EventSearchResult> {
    const result = await this.repository.search(options);
    return {
      events: result.events,
      total: result.total,
      limit: options.limit || 20,
      offset: options.offset || 0,
    };
  }

  async updateEvent(id: string, data: UpdateEventInput): Promise<Event> {
    const event = await this.repository.findById(id);
    if (!event) {
      throw new Error('Event not found');
    }

    if (event.status === 'cancelled') {
      throw new Error('Cannot update cancelled event');
    }

    return this.repository.update(id, {
      ...data,
      updatedAt: new Date(),
    });
  }

  async cancelEvent(id: string, _reason: string): Promise<Event> {
    const event = await this.repository.findById(id);
    if (!event) {
      throw new Error('Event not found');
    }

    if (event.status === 'cancelled') {
      throw new Error('Event is already cancelled');
    }

    if (event.status === 'completed') {
      throw new Error('Cannot cancel completed event');
    }

    return this.repository.update(id, {
      status: 'cancelled',
      updatedAt: new Date(),
    });
  }

  async publishEvent(id: string): Promise<Event> {
    const event = await this.repository.findById(id);
    if (!event) {
      throw new Error('Event not found');
    }

    if (event.status !== 'draft') {
      throw new Error('Only draft events can be published');
    }

    if (event.ticketTypes.length === 0) {
      throw new Error('Event must have at least one ticket type');
    }

    return this.repository.update(id, {
      status: 'published',
      updatedAt: new Date(),
    });
  }

  async getEventsByOrganizer(organizerId: string): Promise<Event[]> {
    return this.repository.findByOrganizer(organizerId);
  }

  async updateTicketAvailability(
    eventId: string,
    ticketTypeId: string,
    soldCount: number,
  ): Promise<Event> {
    const event = await this.repository.findById(eventId);
    if (!event) {
      throw new Error('Event not found');
    }

    const ticketTypes = event.ticketTypes.map((tt) =>
      tt.id === ticketTypeId ? { ...tt, sold: soldCount } : tt,
    );

    const totalSold = ticketTypes.reduce((sum, tt) => sum + tt.sold, 0);
    const newStatus =
      totalSold >= event.capacity && event.status === 'published' ? 'sold-out' : event.status;

    return this.repository.update(eventId, {
      ticketTypes,
      ticketsSold: totalSold,
      status: newStatus,
      updatedAt: new Date(),
    });
  }

  async addTicketType(
    eventId: string,
    ticketType: Omit<TicketType, 'id' | 'sold'>,
  ): Promise<Event> {
    const event = await this.repository.findById(eventId);
    if (!event) {
      throw new Error('Event not found');
    }

    const newTicketType: TicketType = {
      ...ticketType,
      id: `TT-${Date.now()}-${event.ticketTypes.length}`,
      sold: 0,
    };

    return this.repository.update(eventId, {
      ticketTypes: [...event.ticketTypes, newTicketType],
      updatedAt: new Date(),
    });
  }
}

export function createEventService(repository: IEventRepository): IEventService {
  return new EventService(repository);
}
