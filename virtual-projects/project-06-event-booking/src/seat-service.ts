/**
 * SeatService
 * 座席管理・予約・マップ管理
 *
 * @generated by MUSUBIX from C4 design
 * @module seat-service
 * @designElement DES-EVENT-003
 * @traces REQ-EVENT-009, REQ-EVENT-010, REQ-EVENT-011
 */

// ============================================================
// Types & Interfaces
// ============================================================

export interface Seat {
  id: string;
  eventId: string;
  section: string;
  row: string;
  seatNumber: string;
  category: SeatCategory;
  price: number;
  status: SeatStatus;
  reservedBy: string | null;
  reservedAt: Date | null;
  reservationExpiry: Date | null;
  bookedBy: string | null;
}

export type SeatCategory = 'vip' | 'premium' | 'standard' | 'economy';
export type SeatStatus = 'available' | 'reserved' | 'booked' | 'blocked';

export interface SeatSection {
  id: string;
  name: string;
  category: SeatCategory;
  rows: SeatRow[];
  basePrice: number;
}

export interface SeatRow {
  rowId: string;
  seats: number;
  priceModifier: number;
}

export interface VenueLayout {
  id: string;
  eventId: string;
  name: string;
  sections: SeatSection[];
  totalCapacity: number;
  createdAt: Date;
}

export interface SeatReservation {
  id: string;
  eventId: string;
  userId: string;
  seats: string[];
  createdAt: Date;
  expiresAt: Date;
  status: 'active' | 'expired' | 'converted';
}

export interface CreateLayoutInput {
  eventId: string;
  name: string;
  sections: Omit<SeatSection, 'id'>[];
}

export interface ReserveSeatInput {
  eventId: string;
  seatIds: string[];
  userId: string;
  durationMinutes?: number;
}

/**
 * SeatService interface
 * @implements REQ-EVENT-009, REQ-EVENT-010, REQ-EVENT-011
 */
export interface ISeatService {
  createLayout(input: CreateLayoutInput): Promise<VenueLayout>;
  getLayout(eventId: string): Promise<VenueLayout | null>;
  getAvailableSeats(eventId: string, section?: string): Promise<Seat[]>;
  reserveSeats(input: ReserveSeatInput): Promise<SeatReservation>;
  releaseReservation(reservationId: string): Promise<boolean>;
  confirmReservation(reservationId: string, userId: string): Promise<Seat[]>;
  getSeatsByEvent(eventId: string): Promise<Seat[]>;
  blockSeats(eventId: string, seatIds: string[], reason: string): Promise<Seat[]>;
  unblockSeats(seatIds: string[]): Promise<Seat[]>;
  expireOldReservations(): Promise<number>;
}

export interface ISeatRepository {
  save(seat: Seat): Promise<Seat>;
  saveMany(seats: Seat[]): Promise<Seat[]>;
  findById(id: string): Promise<Seat | null>;
  findByEvent(eventId: string): Promise<Seat[]>;
  findAvailable(eventId: string, section?: string): Promise<Seat[]>;
  update(id: string, data: Partial<Seat>): Promise<Seat>;
  updateMany(ids: string[], data: Partial<Seat>): Promise<Seat[]>;
}

export interface ILayoutRepository {
  save(layout: VenueLayout): Promise<VenueLayout>;
  findByEvent(eventId: string): Promise<VenueLayout | null>;
}

export interface IReservationRepository {
  save(reservation: SeatReservation): Promise<SeatReservation>;
  findById(id: string): Promise<SeatReservation | null>;
  findByUser(userId: string, eventId: string): Promise<SeatReservation | null>;
  findExpired(): Promise<SeatReservation[]>;
  update(id: string, data: Partial<SeatReservation>): Promise<SeatReservation>;
  delete(id: string): Promise<boolean>;
}

// ============================================================
// Implementation
// ============================================================

const DEFAULT_RESERVATION_MINUTES = 10;

export class SeatService implements ISeatService {
  constructor(
    private seatRepository: ISeatRepository,
    private layoutRepository: ILayoutRepository,
    private reservationRepository: IReservationRepository,
  ) {}

  async createLayout(input: CreateLayoutInput): Promise<VenueLayout> {
    const sections: SeatSection[] = input.sections.map((s, idx) => ({
      ...s,
      id: `SEC-${idx}`,
    }));

    const totalCapacity = sections.reduce(
      (sum, s) => sum + s.rows.reduce((rowSum, r) => rowSum + r.seats, 0),
      0,
    );

    const layout: VenueLayout = {
      id: `LAY-${Date.now()}`,
      eventId: input.eventId,
      name: input.name,
      sections,
      totalCapacity,
      createdAt: new Date(),
    };

    const savedLayout = await this.layoutRepository.save(layout);

    const seats: Seat[] = [];
    for (const section of sections) {
      for (const row of section.rows) {
        for (let seatNum = 1; seatNum <= row.seats; seatNum++) {
          seats.push({
            id: `${input.eventId}-${section.id}-${row.rowId}-${seatNum}`,
            eventId: input.eventId,
            section: section.name,
            row: row.rowId,
            seatNumber: String(seatNum),
            category: section.category,
            price: section.basePrice * row.priceModifier,
            status: 'available',
            reservedBy: null,
            reservedAt: null,
            reservationExpiry: null,
            bookedBy: null,
          });
        }
      }
    }

    await this.seatRepository.saveMany(seats);

    return savedLayout;
  }

  async getLayout(eventId: string): Promise<VenueLayout | null> {
    return this.layoutRepository.findByEvent(eventId);
  }

  async getAvailableSeats(eventId: string, section?: string): Promise<Seat[]> {
    return this.seatRepository.findAvailable(eventId, section);
  }

  async reserveSeats(input: ReserveSeatInput): Promise<SeatReservation> {
    const existingReservation = await this.reservationRepository.findByUser(
      input.userId,
      input.eventId,
    );

    if (existingReservation && existingReservation.status === 'active') {
      await this.releaseReservation(existingReservation.id);
    }

    const seats = await Promise.all(
      input.seatIds.map((id) => this.seatRepository.findById(id)),
    );

    const unavailableSeats = seats.filter(
      (s) => !s || s.status !== 'available',
    );

    if (unavailableSeats.length > 0) {
      throw new Error('Some seats are not available');
    }

    const now = new Date();
    const durationMs = (input.durationMinutes || DEFAULT_RESERVATION_MINUTES) * 60 * 1000;
    const expiresAt = new Date(now.getTime() + durationMs);

    await this.seatRepository.updateMany(input.seatIds, {
      status: 'reserved',
      reservedBy: input.userId,
      reservedAt: now,
      reservationExpiry: expiresAt,
    });

    const reservation: SeatReservation = {
      id: `RES-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      eventId: input.eventId,
      userId: input.userId,
      seats: input.seatIds,
      createdAt: now,
      expiresAt,
      status: 'active',
    };

    return this.reservationRepository.save(reservation);
  }

  async releaseReservation(reservationId: string): Promise<boolean> {
    const reservation = await this.reservationRepository.findById(reservationId);

    if (!reservation) {
      return false;
    }

    await this.seatRepository.updateMany(reservation.seats, {
      status: 'available',
      reservedBy: null,
      reservedAt: null,
      reservationExpiry: null,
    });

    await this.reservationRepository.update(reservationId, { status: 'expired' });

    return true;
  }

  async confirmReservation(reservationId: string, userId: string): Promise<Seat[]> {
    const reservation = await this.reservationRepository.findById(reservationId);

    if (!reservation) {
      throw new Error('Reservation not found');
    }

    if (reservation.userId !== userId) {
      throw new Error('Not authorized to confirm this reservation');
    }

    if (reservation.status !== 'active') {
      throw new Error('Reservation is no longer active');
    }

    if (new Date() > reservation.expiresAt) {
      await this.releaseReservation(reservationId);
      throw new Error('Reservation has expired');
    }

    const seats = await this.seatRepository.updateMany(reservation.seats, {
      status: 'booked',
      bookedBy: userId,
      reservedBy: null,
      reservedAt: null,
      reservationExpiry: null,
    });

    await this.reservationRepository.update(reservationId, { status: 'converted' });

    return seats;
  }

  async getSeatsByEvent(eventId: string): Promise<Seat[]> {
    return this.seatRepository.findByEvent(eventId);
  }

  async blockSeats(eventId: string, seatIds: string[], _reason: string): Promise<Seat[]> {
    return this.seatRepository.updateMany(seatIds, { status: 'blocked' });
  }

  async unblockSeats(seatIds: string[]): Promise<Seat[]> {
    return this.seatRepository.updateMany(seatIds, { status: 'available' });
  }

  async expireOldReservations(): Promise<number> {
    const expiredReservations = await this.reservationRepository.findExpired();
    let count = 0;

    for (const reservation of expiredReservations) {
      await this.releaseReservation(reservation.id);
      count++;
    }

    return count;
  }
}

export function createSeatService(
  seatRepository: ISeatRepository,
  layoutRepository: ILayoutRepository,
  reservationRepository: IReservationRepository,
): ISeatService {
  return new SeatService(seatRepository, layoutRepository, reservationRepository);
}
