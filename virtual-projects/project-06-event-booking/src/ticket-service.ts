/**
 * TicketService
 * チケット購入・管理・払い戻し
 *
 * @generated by MUSUBIX from C4 design
 * @module ticket-service
 * @designElement DES-EVENT-002
 * @traces REQ-EVENT-005, REQ-EVENT-006, REQ-EVENT-007, REQ-EVENT-008
 */

import { v4 as uuidv4 } from 'uuid';

// ============================================================
// Types & Interfaces
// ============================================================

export interface Ticket {
  id: string;
  eventId: string;
  ticketTypeId: string;
  orderId: string;
  holderId: string;
  holderName: string;
  holderEmail: string;
  qrCode: string;
  seatInfo: SeatInfo | null;
  status: TicketStatus;
  price: number;
  purchasedAt: Date;
  checkedInAt: Date | null;
  transferredAt: Date | null;
  cancelledAt: Date | null;
}

export type TicketStatus = 'active' | 'used' | 'cancelled' | 'transferred' | 'refunded';

export interface SeatInfo {
  section: string;
  row: string;
  seatNumber: string;
}

export interface Order {
  id: string;
  eventId: string;
  buyerId: string;
  tickets: Ticket[];
  totalAmount: number;
  status: OrderStatus;
  paymentId: string | null;
  createdAt: Date;
  completedAt: Date | null;
}

export type OrderStatus = 'pending' | 'completed' | 'cancelled' | 'refunded';

export interface PurchaseTicketInput {
  eventId: string;
  ticketTypeId: string;
  quantity: number;
  buyerId: string;
  buyerName: string;
  buyerEmail: string;
  seatSelections?: SeatInfo[];
}

export interface TransferTicketInput {
  ticketId: string;
  currentHolderId: string;
  newHolderName: string;
  newHolderEmail: string;
}

export interface RefundResult {
  success: boolean;
  ticketId: string;
  refundAmount: number;
  message: string;
}

/**
 * TicketService interface
 * @implements REQ-EVENT-005, REQ-EVENT-006, REQ-EVENT-007, REQ-EVENT-008
 */
export interface ITicketService {
  purchaseTickets(input: PurchaseTicketInput): Promise<Order>;
  getTicket(id: string): Promise<Ticket | null>;
  getTicketByQR(qrCode: string): Promise<Ticket | null>;
  getTicketsByHolder(holderId: string): Promise<Ticket[]>;
  getOrdersByBuyer(buyerId: string): Promise<Order[]>;
  cancelTicket(ticketId: string, holderId: string): Promise<RefundResult>;
  transferTicket(input: TransferTicketInput): Promise<Ticket>;
  getEventTickets(eventId: string): Promise<Ticket[]>;
  validateTicket(qrCode: string): Promise<{ valid: boolean; ticket: Ticket | null; message: string }>;
}

export interface ITicketRepository {
  save(ticket: Ticket): Promise<Ticket>;
  saveMany(tickets: Ticket[]): Promise<Ticket[]>;
  findById(id: string): Promise<Ticket | null>;
  findByQR(qrCode: string): Promise<Ticket | null>;
  findByHolder(holderId: string): Promise<Ticket[]>;
  findByEvent(eventId: string): Promise<Ticket[]>;
  update(id: string, data: Partial<Ticket>): Promise<Ticket>;
}

export interface IOrderRepository {
  save(order: Order): Promise<Order>;
  findById(id: string): Promise<Order | null>;
  findByBuyer(buyerId: string): Promise<Order[]>;
  findByEvent(eventId: string): Promise<Order[]>;
  update(id: string, data: Partial<Order>): Promise<Order>;
}

// ============================================================
// Implementation
// ============================================================

function generateQRCode(): string {
  return `QR-${Date.now()}-${Math.random().toString(36).substr(2, 12).toUpperCase()}`;
}

function generateTicketId(): string {
  return `TKT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

function generateOrderId(): string {
  return `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

export class TicketService implements ITicketService {
  constructor(
    private ticketRepository: ITicketRepository,
    private orderRepository: IOrderRepository,
  ) {}

  async purchaseTickets(input: PurchaseTicketInput): Promise<Order> {
    const tickets: Ticket[] = [];
    const ticketPrice = 5000;

    for (let i = 0; i < input.quantity; i++) {
      const ticket: Ticket = {
        id: generateTicketId(),
        eventId: input.eventId,
        ticketTypeId: input.ticketTypeId,
        orderId: '',
        holderId: input.buyerId,
        holderName: input.buyerName,
        holderEmail: input.buyerEmail,
        qrCode: generateQRCode(),
        seatInfo: input.seatSelections?.[i] || null,
        status: 'active',
        price: ticketPrice,
        purchasedAt: new Date(),
        checkedInAt: null,
        transferredAt: null,
        cancelledAt: null,
      };
      tickets.push(ticket);
    }

    const order: Order = {
      id: generateOrderId(),
      eventId: input.eventId,
      buyerId: input.buyerId,
      tickets: [],
      totalAmount: tickets.reduce((sum, t) => sum + t.price, 0),
      status: 'completed',
      paymentId: `PAY-${Date.now()}`,
      createdAt: new Date(),
      completedAt: new Date(),
    };

    for (const ticket of tickets) {
      ticket.orderId = order.id;
    }

    order.tickets = await this.ticketRepository.saveMany(tickets);
    return this.orderRepository.save(order);
  }

  async getTicket(id: string): Promise<Ticket | null> {
    return this.ticketRepository.findById(id);
  }

  async getTicketByQR(qrCode: string): Promise<Ticket | null> {
    return this.ticketRepository.findByQR(qrCode);
  }

  async getTicketsByHolder(holderId: string): Promise<Ticket[]> {
    return this.ticketRepository.findByHolder(holderId);
  }

  async getOrdersByBuyer(buyerId: string): Promise<Order[]> {
    return this.orderRepository.findByBuyer(buyerId);
  }

  async cancelTicket(ticketId: string, holderId: string): Promise<RefundResult> {
    const ticket = await this.ticketRepository.findById(ticketId);

    if (!ticket) {
      return {
        success: false,
        ticketId,
        refundAmount: 0,
        message: 'Ticket not found',
      };
    }

    if (ticket.holderId !== holderId) {
      return {
        success: false,
        ticketId,
        refundAmount: 0,
        message: 'Not authorized to cancel this ticket',
      };
    }

    if (ticket.status !== 'active') {
      return {
        success: false,
        ticketId,
        refundAmount: 0,
        message: `Cannot cancel ticket with status: ${ticket.status}`,
      };
    }

    await this.ticketRepository.update(ticketId, {
      status: 'refunded',
      cancelledAt: new Date(),
    });

    return {
      success: true,
      ticketId,
      refundAmount: ticket.price,
      message: 'Ticket cancelled and refund initiated',
    };
  }

  async transferTicket(input: TransferTicketInput): Promise<Ticket> {
    const ticket = await this.ticketRepository.findById(input.ticketId);

    if (!ticket) {
      throw new Error('Ticket not found');
    }

    if (ticket.holderId !== input.currentHolderId) {
      throw new Error('Not authorized to transfer this ticket');
    }

    if (ticket.status !== 'active') {
      throw new Error(`Cannot transfer ticket with status: ${ticket.status}`);
    }

    const newQRCode = generateQRCode();

    return this.ticketRepository.update(input.ticketId, {
      holderName: input.newHolderName,
      holderEmail: input.newHolderEmail,
      qrCode: newQRCode,
      status: 'transferred',
      transferredAt: new Date(),
    });
  }

  async getEventTickets(eventId: string): Promise<Ticket[]> {
    return this.ticketRepository.findByEvent(eventId);
  }

  async validateTicket(
    qrCode: string,
  ): Promise<{ valid: boolean; ticket: Ticket | null; message: string }> {
    const ticket = await this.ticketRepository.findByQR(qrCode);

    if (!ticket) {
      return { valid: false, ticket: null, message: 'Invalid ticket' };
    }

    if (ticket.status === 'used') {
      return { valid: false, ticket, message: 'Ticket already used' };
    }

    if (ticket.status === 'cancelled' || ticket.status === 'refunded') {
      return { valid: false, ticket, message: 'Ticket has been cancelled' };
    }

    if (ticket.status !== 'active' && ticket.status !== 'transferred') {
      return { valid: false, ticket, message: `Invalid ticket status: ${ticket.status}` };
    }

    return { valid: true, ticket, message: 'Valid ticket' };
  }
}

export function createTicketService(
  ticketRepository: ITicketRepository,
  orderRepository: IOrderRepository,
): ITicketService {
  return new TicketService(ticketRepository, orderRepository);
}
