/**
 * PaymentService
 * 支払い・課金・請求管理
 *
 * @generated by MUSUBIX from C4 design
 * @module payment-service
 * @designElement DES-GYM-006
 * @traces REQ-GYM-015, REQ-GYM-016, REQ-GYM-017
 */

// ============================================================
// Types & Interfaces
// ============================================================

export interface Payment {
  id: string;
  memberId: string;
  amount: number;
  currency: string;
  type: PaymentType;
  method: PaymentMethod;
  status: PaymentStatus;
  description: string;
  invoiceId: string | null;
  transactionId: string | null;
  processedAt: Date | null;
  createdAt: Date;
  metadata: Record<string, unknown>;
}

export type PaymentType = 'membership' | 'session' | 'product' | 'late-fee' | 'refund';
export type PaymentMethod = 'credit-card' | 'debit-card' | 'bank-transfer' | 'cash' | 'digital-wallet';
export type PaymentStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'refunded' | 'cancelled';

export interface Invoice {
  id: string;
  memberId: string;
  items: InvoiceItem[];
  subtotal: number;
  tax: number;
  total: number;
  status: InvoiceStatus;
  dueDate: Date;
  paidAt: Date | null;
  createdAt: Date;
  notes: string | null;
}

export interface InvoiceItem {
  description: string;
  quantity: number;
  unitPrice: number;
  total: number;
}

export type InvoiceStatus = 'draft' | 'sent' | 'paid' | 'overdue' | 'cancelled';

export interface Subscription {
  id: string;
  memberId: string;
  planId: string;
  planName: string;
  amount: number;
  billingCycle: BillingCycle;
  status: SubscriptionStatus;
  startDate: Date;
  currentPeriodStart: Date;
  currentPeriodEnd: Date;
  cancelledAt: Date | null;
  autoRenew: boolean;
}

export type BillingCycle = 'monthly' | 'quarterly' | 'annually';
export type SubscriptionStatus = 'active' | 'past-due' | 'cancelled' | 'paused';

export interface CreatePaymentInput {
  memberId: string;
  amount: number;
  currency?: string;
  type: PaymentType;
  method: PaymentMethod;
  description: string;
  invoiceId?: string;
}

export interface CreateInvoiceInput {
  memberId: string;
  items: InvoiceItem[];
  dueDate: Date;
  notes?: string;
}

export interface RevenueReport {
  period: { from: Date; to: Date };
  totalRevenue: number;
  membershipRevenue: number;
  sessionRevenue: number;
  productRevenue: number;
  refunds: number;
  netRevenue: number;
  transactionCount: number;
  averageTransactionValue: number;
  byPaymentMethod: Record<PaymentMethod, number>;
}

/**
 * PaymentService interface
 * @implements REQ-GYM-015, REQ-GYM-016, REQ-GYM-017
 */
export interface IPaymentService {
  createPayment(data: CreatePaymentInput): Promise<Payment>;
  getPayment(id: string): Promise<Payment | null>;
  getMemberPayments(memberId: string): Promise<Payment[]>;
  processPayment(paymentId: string): Promise<Payment>;
  refundPayment(paymentId: string, reason: string): Promise<Payment>;
  createInvoice(data: CreateInvoiceInput): Promise<Invoice>;
  getInvoice(id: string): Promise<Invoice | null>;
  getMemberInvoices(memberId: string): Promise<Invoice[]>;
  sendInvoice(invoiceId: string): Promise<Invoice>;
  markInvoicePaid(invoiceId: string, paymentId: string): Promise<Invoice>;
  createSubscription(memberId: string, planId: string): Promise<Subscription>;
  getSubscription(id: string): Promise<Subscription | null>;
  getMemberSubscription(memberId: string): Promise<Subscription | null>;
  cancelSubscription(id: string, immediate: boolean): Promise<Subscription>;
  pauseSubscription(id: string): Promise<Subscription>;
  resumeSubscription(id: string): Promise<Subscription>;
  getOverdueInvoices(): Promise<Invoice[]>;
  generateRevenueReport(period: { from: Date; to: Date }): Promise<RevenueReport>;
}

export interface IPaymentRepository {
  save(payment: Payment): Promise<Payment>;
  findById(id: string): Promise<Payment | null>;
  findByMember(memberId: string): Promise<Payment[]>;
  findByStatus(status: PaymentStatus): Promise<Payment[]>;
  update(id: string, data: Partial<Payment>): Promise<Payment>;
  findByPeriod(period: { from: Date; to: Date }): Promise<Payment[]>;
}

export interface IInvoiceRepository {
  save(invoice: Invoice): Promise<Invoice>;
  findById(id: string): Promise<Invoice | null>;
  findByMember(memberId: string): Promise<Invoice[]>;
  findOverdue(): Promise<Invoice[]>;
  update(id: string, data: Partial<Invoice>): Promise<Invoice>;
}

export interface ISubscriptionRepository {
  save(subscription: Subscription): Promise<Subscription>;
  findById(id: string): Promise<Subscription | null>;
  findByMember(memberId: string): Promise<Subscription | null>;
  findByStatus(status: SubscriptionStatus): Promise<Subscription[]>;
  update(id: string, data: Partial<Subscription>): Promise<Subscription>;
}

// ============================================================
// Implementation
// ============================================================

export class PaymentService implements IPaymentService {
  private taxRate = 0.1;

  constructor(
    private paymentRepository: IPaymentRepository,
    private invoiceRepository: IInvoiceRepository,
    private subscriptionRepository: ISubscriptionRepository,
  ) {}

  async createPayment(data: CreatePaymentInput): Promise<Payment> {
    const payment: Payment = {
      id: `PAY-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      memberId: data.memberId,
      amount: data.amount,
      currency: data.currency || 'JPY',
      type: data.type,
      method: data.method,
      status: 'pending',
      description: data.description,
      invoiceId: data.invoiceId || null,
      transactionId: null,
      processedAt: null,
      createdAt: new Date(),
      metadata: {},
    };

    return this.paymentRepository.save(payment);
  }

  async getPayment(id: string): Promise<Payment | null> {
    return this.paymentRepository.findById(id);
  }

  async getMemberPayments(memberId: string): Promise<Payment[]> {
    return this.paymentRepository.findByMember(memberId);
  }

  async processPayment(paymentId: string): Promise<Payment> {
    const payment = await this.paymentRepository.findById(paymentId);
    if (!payment) {
      throw new Error('Payment not found');
    }

    if (payment.status !== 'pending') {
      throw new Error(`Cannot process payment with status: ${payment.status}`);
    }

    await this.paymentRepository.update(paymentId, { status: 'processing' });

    const success = Math.random() > 0.05;

    if (success) {
      return this.paymentRepository.update(paymentId, {
        status: 'completed',
        transactionId: `TXN-${Date.now()}`,
        processedAt: new Date(),
      });
    } else {
      return this.paymentRepository.update(paymentId, {
        status: 'failed',
        metadata: { error: 'Payment declined' },
      });
    }
  }

  async refundPayment(paymentId: string, _reason: string): Promise<Payment> {
    const payment = await this.paymentRepository.findById(paymentId);
    if (!payment) {
      throw new Error('Payment not found');
    }

    if (payment.status !== 'completed') {
      throw new Error('Can only refund completed payments');
    }

    return this.paymentRepository.update(paymentId, {
      status: 'refunded',
      processedAt: new Date(),
    });
  }

  async createInvoice(data: CreateInvoiceInput): Promise<Invoice> {
    const subtotal = data.items.reduce((sum, item) => sum + item.total, 0);
    const tax = Math.round(subtotal * this.taxRate);

    const invoice: Invoice = {
      id: `INV-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      memberId: data.memberId,
      items: data.items,
      subtotal,
      tax,
      total: subtotal + tax,
      status: 'draft',
      dueDate: data.dueDate,
      paidAt: null,
      createdAt: new Date(),
      notes: data.notes || null,
    };

    return this.invoiceRepository.save(invoice);
  }

  async getInvoice(id: string): Promise<Invoice | null> {
    return this.invoiceRepository.findById(id);
  }

  async getMemberInvoices(memberId: string): Promise<Invoice[]> {
    return this.invoiceRepository.findByMember(memberId);
  }

  async sendInvoice(invoiceId: string): Promise<Invoice> {
    const invoice = await this.invoiceRepository.findById(invoiceId);
    if (!invoice) {
      throw new Error('Invoice not found');
    }

    return this.invoiceRepository.update(invoiceId, { status: 'sent' });
  }

  async markInvoicePaid(invoiceId: string, _paymentId: string): Promise<Invoice> {
    const invoice = await this.invoiceRepository.findById(invoiceId);
    if (!invoice) {
      throw new Error('Invoice not found');
    }

    return this.invoiceRepository.update(invoiceId, {
      status: 'paid',
      paidAt: new Date(),
    });
  }

  async createSubscription(memberId: string, planId: string): Promise<Subscription> {
    const existingSubscription = await this.subscriptionRepository.findByMember(memberId);
    if (existingSubscription && existingSubscription.status === 'active') {
      throw new Error('Member already has an active subscription');
    }

    const plans: Record<string, { name: string; amount: number; cycle: BillingCycle }> = {
      basic: { name: 'Basic Plan', amount: 5000, cycle: 'monthly' },
      standard: { name: 'Standard Plan', amount: 8000, cycle: 'monthly' },
      premium: { name: 'Premium Plan', amount: 12000, cycle: 'monthly' },
    };

    const plan = plans[planId];
    if (!plan) {
      throw new Error('Invalid plan');
    }

    const now = new Date();
    const periodEnd = new Date(now);
    periodEnd.setMonth(periodEnd.getMonth() + 1);

    const subscription: Subscription = {
      id: `SUB-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      memberId,
      planId,
      planName: plan.name,
      amount: plan.amount,
      billingCycle: plan.cycle,
      status: 'active',
      startDate: now,
      currentPeriodStart: now,
      currentPeriodEnd: periodEnd,
      cancelledAt: null,
      autoRenew: true,
    };

    return this.subscriptionRepository.save(subscription);
  }

  async getSubscription(id: string): Promise<Subscription | null> {
    return this.subscriptionRepository.findById(id);
  }

  async getMemberSubscription(memberId: string): Promise<Subscription | null> {
    return this.subscriptionRepository.findByMember(memberId);
  }

  async cancelSubscription(id: string, immediate: boolean): Promise<Subscription> {
    const subscription = await this.subscriptionRepository.findById(id);
    if (!subscription) {
      throw new Error('Subscription not found');
    }

    if (immediate) {
      return this.subscriptionRepository.update(id, {
        status: 'cancelled',
        cancelledAt: new Date(),
        autoRenew: false,
      });
    } else {
      return this.subscriptionRepository.update(id, {
        autoRenew: false,
        cancelledAt: new Date(),
      });
    }
  }

  async pauseSubscription(id: string): Promise<Subscription> {
    return this.subscriptionRepository.update(id, { status: 'paused' });
  }

  async resumeSubscription(id: string): Promise<Subscription> {
    return this.subscriptionRepository.update(id, { status: 'active' });
  }

  async getOverdueInvoices(): Promise<Invoice[]> {
    return this.invoiceRepository.findOverdue();
  }

  async generateRevenueReport(period: { from: Date; to: Date }): Promise<RevenueReport> {
    const payments = await this.paymentRepository.findByPeriod(period);
    const completedPayments = payments.filter((p) => p.status === 'completed');
    const refunds = payments.filter((p) => p.status === 'refunded');

    const totalRevenue = completedPayments.reduce((sum, p) => sum + p.amount, 0);
    const refundAmount = refunds.reduce((sum, p) => sum + p.amount, 0);

    const membershipRevenue = completedPayments
      .filter((p) => p.type === 'membership')
      .reduce((sum, p) => sum + p.amount, 0);

    const sessionRevenue = completedPayments
      .filter((p) => p.type === 'session')
      .reduce((sum, p) => sum + p.amount, 0);

    const productRevenue = completedPayments
      .filter((p) => p.type === 'product')
      .reduce((sum, p) => sum + p.amount, 0);

    const byPaymentMethod = completedPayments.reduce(
      (acc, p) => {
        acc[p.method] = (acc[p.method] || 0) + p.amount;
        return acc;
      },
      {} as Record<PaymentMethod, number>,
    );

    return {
      period,
      totalRevenue,
      membershipRevenue,
      sessionRevenue,
      productRevenue,
      refunds: refundAmount,
      netRevenue: totalRevenue - refundAmount,
      transactionCount: completedPayments.length,
      averageTransactionValue: completedPayments.length > 0 ? totalRevenue / completedPayments.length : 0,
      byPaymentMethod,
    };
  }
}

export function createPaymentService(
  paymentRepository: IPaymentRepository,
  invoiceRepository: IInvoiceRepository,
  subscriptionRepository: ISubscriptionRepository,
): IPaymentService {
  return new PaymentService(paymentRepository, invoiceRepository, subscriptionRepository);
}
