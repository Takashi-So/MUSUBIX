/**
 * BookingService
 * 施設・クラス予約管理
 *
 * @generated by MUSUBIX from C4 design
 * @module booking-service
 * @designElement DES-GYM-003
 * @traces REQ-GYM-005, REQ-GYM-006, REQ-GYM-007, REQ-GYM-008
 */

// ============================================================
// Types & Interfaces
// ============================================================

export interface Booking {
  id: string;
  memberId: string;
  resourceType: 'class' | 'equipment' | 'trainer' | 'facility';
  resourceId: string;
  scheduledStart: Date;
  scheduledEnd: Date;
  status: BookingStatus;
  createdAt: Date;
  updatedAt: Date;
  notes: string | null;
  cancellationReason: string | null;
}

export type BookingStatus = 'confirmed' | 'pending' | 'cancelled' | 'completed' | 'no-show';

export interface GymClass {
  id: string;
  name: string;
  description: string;
  instructorId: string;
  capacity: number;
  currentEnrollment: number;
  duration: number;
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  category: 'yoga' | 'pilates' | 'cardio' | 'strength' | 'dance' | 'martial-arts' | 'other';
  schedule: ClassSchedule[];
}

export interface ClassSchedule {
  dayOfWeek: number;
  startTime: string;
  endTime: string;
  roomId: string;
}

export interface CreateBookingInput {
  memberId: string;
  resourceType: 'class' | 'equipment' | 'trainer' | 'facility';
  resourceId: string;
  scheduledStart: Date;
  scheduledEnd: Date;
  notes?: string;
}

export interface BookingFilterOptions {
  memberId?: string;
  resourceType?: 'class' | 'equipment' | 'trainer' | 'facility';
  resourceId?: string;
  status?: BookingStatus;
  dateFrom?: Date;
  dateTo?: Date;
}

export interface AvailabilitySlot {
  startTime: Date;
  endTime: Date;
  available: boolean;
  remainingCapacity: number;
}

export interface WaitlistEntry {
  id: string;
  memberId: string;
  classId: string;
  position: number;
  addedAt: Date;
}

/**
 * BookingService interface
 * @implements REQ-GYM-005, REQ-GYM-006, REQ-GYM-007, REQ-GYM-008
 */
export interface IBookingService {
  createBooking(data: CreateBookingInput): Promise<Booking>;
  getBooking(id: string): Promise<Booking | null>;
  getMemberBookings(memberId: string, filter?: BookingFilterOptions): Promise<Booking[]>;
  cancelBooking(id: string, reason?: string): Promise<Booking>;
  rescheduleBooking(id: string, newStart: Date, newEnd: Date): Promise<Booking>;
  checkAvailability(resourceType: string, resourceId: string, date: Date): Promise<AvailabilitySlot[]>;
  addToWaitlist(memberId: string, classId: string): Promise<WaitlistEntry>;
  getWaitlistPosition(memberId: string, classId: string): Promise<number | null>;
  getUpcomingClasses(memberId: string, days: number): Promise<GymClass[]>;
  markAttendance(bookingId: string, attended: boolean): Promise<Booking>;
}

export interface IBookingRepository {
  save(booking: Booking): Promise<Booking>;
  findById(id: string): Promise<Booking | null>;
  findByMember(memberId: string, filter?: BookingFilterOptions): Promise<Booking[]>;
  findByResource(resourceType: string, resourceId: string, dateRange: { from: Date; to: Date }): Promise<Booking[]>;
  update(id: string, data: Partial<Booking>): Promise<Booking>;
  delete(id: string): Promise<boolean>;
  getWaitlist(classId: string): Promise<WaitlistEntry[]>;
  addToWaitlist(entry: WaitlistEntry): Promise<WaitlistEntry>;
  removeFromWaitlist(memberId: string, classId: string): Promise<boolean>;
}

export interface IClassRepository {
  findById(id: string): Promise<GymClass | null>;
  findBySchedule(date: Date): Promise<GymClass[]>;
  findUpcoming(days: number): Promise<GymClass[]>;
  updateEnrollment(id: string, count: number): Promise<GymClass>;
}

// ============================================================
// Implementation
// ============================================================

export class BookingService implements IBookingService {
  constructor(
    private bookingRepository: IBookingRepository,
    private classRepository: IClassRepository,
  ) {}

  async createBooking(data: CreateBookingInput): Promise<Booking> {
    const existingBookings = await this.bookingRepository.findByResource(
      data.resourceType,
      data.resourceId,
      { from: data.scheduledStart, to: data.scheduledEnd },
    );

    const conflictingBooking = existingBookings.find(
      (b) =>
        b.status !== 'cancelled' &&
        b.scheduledStart < data.scheduledEnd &&
        b.scheduledEnd > data.scheduledStart,
    );

    if (conflictingBooking) {
      throw new Error('Time slot is not available');
    }

    if (data.resourceType === 'class') {
      const gymClass = await this.classRepository.findById(data.resourceId);
      if (gymClass && gymClass.currentEnrollment >= gymClass.capacity) {
        throw new Error('Class is full. Consider joining the waitlist.');
      }
      if (gymClass) {
        await this.classRepository.updateEnrollment(gymClass.id, gymClass.currentEnrollment + 1);
      }
    }

    const booking: Booking = {
      id: `BK-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      memberId: data.memberId,
      resourceType: data.resourceType,
      resourceId: data.resourceId,
      scheduledStart: data.scheduledStart,
      scheduledEnd: data.scheduledEnd,
      status: 'confirmed',
      createdAt: new Date(),
      updatedAt: new Date(),
      notes: data.notes || null,
      cancellationReason: null,
    };

    return this.bookingRepository.save(booking);
  }

  async getBooking(id: string): Promise<Booking | null> {
    return this.bookingRepository.findById(id);
  }

  async getMemberBookings(memberId: string, filter?: BookingFilterOptions): Promise<Booking[]> {
    return this.bookingRepository.findByMember(memberId, filter);
  }

  async cancelBooking(id: string, reason?: string): Promise<Booking> {
    const booking = await this.bookingRepository.findById(id);
    if (!booking) {
      throw new Error('Booking not found');
    }

    if (booking.status === 'cancelled') {
      throw new Error('Booking is already cancelled');
    }

    if (booking.resourceType === 'class') {
      const gymClass = await this.classRepository.findById(booking.resourceId);
      if (gymClass) {
        await this.classRepository.updateEnrollment(gymClass.id, Math.max(0, gymClass.currentEnrollment - 1));

        const waitlist = await this.bookingRepository.getWaitlist(booking.resourceId);
        if (waitlist.length > 0) {
          const nextInLine = waitlist[0];
          await this.createBooking({
            memberId: nextInLine.memberId,
            resourceType: 'class',
            resourceId: booking.resourceId,
            scheduledStart: booking.scheduledStart,
            scheduledEnd: booking.scheduledEnd,
          });
          await this.bookingRepository.removeFromWaitlist(nextInLine.memberId, booking.resourceId);
        }
      }
    }

    return this.bookingRepository.update(id, {
      status: 'cancelled',
      cancellationReason: reason || null,
      updatedAt: new Date(),
    });
  }

  async rescheduleBooking(id: string, newStart: Date, newEnd: Date): Promise<Booking> {
    const booking = await this.bookingRepository.findById(id);
    if (!booking) {
      throw new Error('Booking not found');
    }

    const existingBookings = await this.bookingRepository.findByResource(
      booking.resourceType,
      booking.resourceId,
      { from: newStart, to: newEnd },
    );

    const conflict = existingBookings.find(
      (b) => b.id !== id && b.status !== 'cancelled' && b.scheduledStart < newEnd && b.scheduledEnd > newStart,
    );

    if (conflict) {
      throw new Error('New time slot is not available');
    }

    return this.bookingRepository.update(id, {
      scheduledStart: newStart,
      scheduledEnd: newEnd,
      updatedAt: new Date(),
    });
  }

  async checkAvailability(resourceType: string, resourceId: string, date: Date): Promise<AvailabilitySlot[]> {
    const startOfDay = new Date(date);
    startOfDay.setHours(6, 0, 0, 0);
    const endOfDay = new Date(date);
    endOfDay.setHours(22, 0, 0, 0);

    const existingBookings = await this.bookingRepository.findByResource(resourceType, resourceId, {
      from: startOfDay,
      to: endOfDay,
    });

    const slots: AvailabilitySlot[] = [];
    let currentTime = new Date(startOfDay);

    while (currentTime < endOfDay) {
      const slotEnd = new Date(currentTime.getTime() + 60 * 60 * 1000);
      const isBooked = existingBookings.some(
        (b) =>
          b.status !== 'cancelled' && b.scheduledStart < slotEnd && b.scheduledEnd > currentTime,
      );

      slots.push({
        startTime: new Date(currentTime),
        endTime: slotEnd,
        available: !isBooked,
        remainingCapacity: isBooked ? 0 : 1,
      });

      currentTime = slotEnd;
    }

    return slots;
  }

  async addToWaitlist(memberId: string, classId: string): Promise<WaitlistEntry> {
    const existingWaitlist = await this.bookingRepository.getWaitlist(classId);
    
    const alreadyInList = existingWaitlist.find((e) => e.memberId === memberId);
    if (alreadyInList) {
      throw new Error('Already on the waitlist');
    }

    const entry: WaitlistEntry = {
      id: `WL-${Date.now()}`,
      memberId,
      classId,
      position: existingWaitlist.length + 1,
      addedAt: new Date(),
    };

    return this.bookingRepository.addToWaitlist(entry);
  }

  async getWaitlistPosition(memberId: string, classId: string): Promise<number | null> {
    const waitlist = await this.bookingRepository.getWaitlist(classId);
    const entry = waitlist.find((e) => e.memberId === memberId);
    return entry ? entry.position : null;
  }

  async getUpcomingClasses(_memberId: string, days: number): Promise<GymClass[]> {
    return this.classRepository.findUpcoming(days);
  }

  async markAttendance(bookingId: string, attended: boolean): Promise<Booking> {
    return this.bookingRepository.update(bookingId, {
      status: attended ? 'completed' : 'no-show',
      updatedAt: new Date(),
    });
  }
}

export function createBookingService(
  bookingRepository: IBookingRepository,
  classRepository: IClassRepository,
): IBookingService {
  return new BookingService(bookingRepository, classRepository);
}
