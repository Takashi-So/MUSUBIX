/**
 * MemberService
 * 会員登録・認証・プロフィール管理
 *
 * @generated by MUSUBIX from C4 design
 * @module member-service
 * @designElement DES-GYM-001
 * @traces REQ-GYM-001, REQ-GYM-002, REQ-GYM-003
 */

// ============================================================
// Types & Interfaces
// ============================================================

export interface Member {
  id: string;
  name: string;
  email: string;
  phone: string;
  emergencyContact: {
    name: string;
    phone: string;
    relationship: string;
  };
  membershipId: string;
  status: MemberStatus;
  joinDate: Date;
  lastVisit: Date | null;
  profilePhoto: string | null;
}

export type MemberStatus = 'active' | 'inactive' | 'suspended' | 'expired';

export interface CreateMemberInput {
  name: string;
  email: string;
  phone: string;
  emergencyContact: {
    name: string;
    phone: string;
    relationship: string;
  };
  membershipPlanId: string;
}

export interface UpdateMemberInput {
  name?: string;
  email?: string;
  phone?: string;
  emergencyContact?: {
    name: string;
    phone: string;
    relationship: string;
  };
  profilePhoto?: string;
}

export interface MemberFilterOptions {
  status?: MemberStatus;
  membershipPlanId?: string;
  joinDateFrom?: Date;
  joinDateTo?: Date;
}

export interface CheckInResult {
  success: boolean;
  memberId: string;
  timestamp: Date;
  message: string;
  membershipStatus: MemberStatus;
  remainingSessions: number | null;
}

export interface UsageRecord {
  id: string;
  memberId: string;
  checkInTime: Date;
  checkOutTime: Date | null;
  duration: number;
  activities: string[];
}

/**
 * MemberService interface
 * @implements REQ-GYM-001, REQ-GYM-002, REQ-GYM-003
 */
export interface IMemberService {
  create(data: CreateMemberInput): Promise<Member>;
  getById(id: string): Promise<Member | null>;
  getByEmail(email: string): Promise<Member | null>;
  getAll(filter?: MemberFilterOptions): Promise<Member[]>;
  update(id: string, data: UpdateMemberInput): Promise<Member>;
  delete(id: string): Promise<boolean>;
  checkIn(memberId: string): Promise<CheckInResult>;
  checkOut(memberId: string): Promise<boolean>;
  verifyMembershipCard(cardNumber: string): Promise<Member | null>;
  activate(id: string): Promise<Member>;
  suspend(id: string, reason: string): Promise<Member>;
  getUsageHistory(id: string, days: number): Promise<UsageRecord[]>;
}

export interface IMemberRepository {
  save(member: Member): Promise<Member>;
  findById(id: string): Promise<Member | null>;
  findByEmail(email: string): Promise<Member | null>;
  findByCardNumber(cardNumber: string): Promise<Member | null>;
  findAll(filter?: MemberFilterOptions): Promise<Member[]>;
  update(id: string, data: Partial<Member>): Promise<Member>;
  delete(id: string): Promise<boolean>;
  saveUsageRecord(record: UsageRecord): Promise<UsageRecord>;
  getUsageRecords(memberId: string, days: number): Promise<UsageRecord[]>;
}

// ============================================================
// Implementation
// ============================================================

export class MemberService implements IMemberService {
  constructor(private repository: IMemberRepository) {}

  async create(data: CreateMemberInput): Promise<Member> {
    const existingMember = await this.repository.findByEmail(data.email);
    if (existingMember) {
      throw new Error('Member with this email already exists');
    }
    
    const member: Member = {
      id: `MEM-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name: data.name,
      email: data.email,
      phone: data.phone,
      emergencyContact: data.emergencyContact,
      membershipId: data.membershipPlanId,
      status: 'active',
      joinDate: new Date(),
      lastVisit: null,
      profilePhoto: null,
    };
    
    return this.repository.save(member);
  }

  async getById(id: string): Promise<Member | null> {
    return this.repository.findById(id);
  }

  async getByEmail(email: string): Promise<Member | null> {
    return this.repository.findByEmail(email);
  }

  async getAll(filter?: MemberFilterOptions): Promise<Member[]> {
    return this.repository.findAll(filter);
  }

  async update(id: string, data: UpdateMemberInput): Promise<Member> {
    const member = await this.repository.findById(id);
    if (!member) {
      throw new Error('Member not found');
    }
    return this.repository.update(id, data);
  }

  async delete(id: string): Promise<boolean> {
    return this.repository.delete(id);
  }

  async checkIn(memberId: string): Promise<CheckInResult> {
    const member = await this.repository.findById(memberId);
    
    if (!member) {
      return {
        success: false,
        memberId,
        timestamp: new Date(),
        message: 'Member not found',
        membershipStatus: 'inactive',
        remainingSessions: null,
      };
    }
    
    if (member.status !== 'active') {
      return {
        success: false,
        memberId,
        timestamp: new Date(),
        message: `Membership is ${member.status}`,
        membershipStatus: member.status,
        remainingSessions: null,
      };
    }
    
    const usageRecord: UsageRecord = {
      id: `USE-${Date.now()}`,
      memberId,
      checkInTime: new Date(),
      checkOutTime: null,
      duration: 0,
      activities: [],
    };
    await this.repository.saveUsageRecord(usageRecord);
    await this.repository.update(memberId, { lastVisit: new Date() } as Partial<Member>);
    
    return {
      success: true,
      memberId,
      timestamp: new Date(),
      message: `Welcome back, ${member.name}!`,
      membershipStatus: member.status,
      remainingSessions: null,
    };
  }

  async checkOut(memberId: string): Promise<boolean> {
    return true;
  }

  async verifyMembershipCard(cardNumber: string): Promise<Member | null> {
    return this.repository.findByCardNumber(cardNumber);
  }

  async activate(id: string): Promise<Member> {
    return this.repository.update(id, { status: 'active' });
  }

  async suspend(id: string, _reason: string): Promise<Member> {
    return this.repository.update(id, { status: 'suspended' });
  }

  async getUsageHistory(id: string, days: number): Promise<UsageRecord[]> {
    return this.repository.getUsageRecords(id, days);
  }
}

export function createMemberService(repository: IMemberRepository): IMemberService {
  return new MemberService(repository);
}
