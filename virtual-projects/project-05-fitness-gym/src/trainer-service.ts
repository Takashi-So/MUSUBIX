/**
 * TrainerService
 * パーソナルトレーナー管理・スケジュール
 *
 * @generated by MUSUBIX from C4 design
 * @module trainer-service
 * @designElement DES-GYM-004
 * @traces REQ-GYM-009, REQ-GYM-010, REQ-GYM-011
 */

// ============================================================
// Types & Interfaces
// ============================================================

export interface Trainer {
  id: string;
  name: string;
  email: string;
  phone: string;
  specializations: Specialization[];
  certifications: Certification[];
  bio: string;
  profilePhoto: string | null;
  hourlyRate: number;
  availability: WeeklyAvailability;
  status: TrainerStatus;
  rating: number;
  reviewCount: number;
  hireDate: Date;
}

export type TrainerStatus = 'active' | 'on-leave' | 'terminated';

export type Specialization =
  | 'strength-training'
  | 'cardio'
  | 'yoga'
  | 'pilates'
  | 'nutrition'
  | 'rehabilitation'
  | 'weight-loss'
  | 'bodybuilding'
  | 'functional-fitness'
  | 'sports-specific';

export interface Certification {
  name: string;
  issuingBody: string;
  issueDate: Date;
  expiryDate: Date | null;
  verified: boolean;
}

export interface WeeklyAvailability {
  monday: TimeSlot[];
  tuesday: TimeSlot[];
  wednesday: TimeSlot[];
  thursday: TimeSlot[];
  friday: TimeSlot[];
  saturday: TimeSlot[];
  sunday: TimeSlot[];
}

export interface TimeSlot {
  startTime: string;
  endTime: string;
}

export interface TrainerSession {
  id: string;
  trainerId: string;
  memberId: string;
  scheduledStart: Date;
  scheduledEnd: Date;
  status: SessionStatus;
  sessionType: SessionType;
  notes: string | null;
  memberFeedback: string | null;
  memberRating: number | null;
  createdAt: Date;
}

export type SessionStatus = 'scheduled' | 'in-progress' | 'completed' | 'cancelled' | 'no-show';
export type SessionType = 'initial-assessment' | 'training' | 'follow-up' | 'nutrition-consultation';

export interface CreateTrainerInput {
  name: string;
  email: string;
  phone: string;
  specializations: Specialization[];
  certifications: Certification[];
  bio: string;
  hourlyRate: number;
  availability: WeeklyAvailability;
}

export interface TrainerFilterOptions {
  specialization?: Specialization;
  status?: TrainerStatus;
  minRating?: number;
  availableOn?: Date;
}

export interface TrainerPerformanceMetrics {
  trainerId: string;
  totalSessions: number;
  completedSessions: number;
  cancelledSessions: number;
  noShowSessions: number;
  averageRating: number;
  totalRevenue: number;
  clientRetentionRate: number;
  period: { from: Date; to: Date };
}

/**
 * TrainerService interface
 * @implements REQ-GYM-009, REQ-GYM-010, REQ-GYM-011
 */
export interface ITrainerService {
  createTrainer(data: CreateTrainerInput): Promise<Trainer>;
  getTrainer(id: string): Promise<Trainer | null>;
  getAllTrainers(filter?: TrainerFilterOptions): Promise<Trainer[]>;
  updateTrainer(id: string, data: Partial<CreateTrainerInput>): Promise<Trainer>;
  getAvailableTrainers(date: Date, specialization?: Specialization): Promise<Trainer[]>;
  getTrainerSchedule(trainerId: string, weekStart: Date): Promise<TrainerSession[]>;
  bookSession(memberId: string, trainerId: string, start: Date, end: Date, type: SessionType): Promise<TrainerSession>;
  cancelSession(sessionId: string, reason?: string): Promise<TrainerSession>;
  completeSession(sessionId: string, notes?: string): Promise<TrainerSession>;
  addSessionFeedback(sessionId: string, rating: number, feedback: string): Promise<TrainerSession>;
  getTrainerPerformance(trainerId: string, period: { from: Date; to: Date }): Promise<TrainerPerformanceMetrics>;
  assignToClass(trainerId: string, classId: string): Promise<void>;
}

export interface ITrainerRepository {
  save(trainer: Trainer): Promise<Trainer>;
  findById(id: string): Promise<Trainer | null>;
  findByEmail(email: string): Promise<Trainer | null>;
  findAll(filter?: TrainerFilterOptions): Promise<Trainer[]>;
  update(id: string, data: Partial<Trainer>): Promise<Trainer>;
  delete(id: string): Promise<boolean>;
}

export interface ITrainerSessionRepository {
  save(session: TrainerSession): Promise<TrainerSession>;
  findById(id: string): Promise<TrainerSession | null>;
  findByTrainer(trainerId: string, dateRange: { from: Date; to: Date }): Promise<TrainerSession[]>;
  findByMember(memberId: string, dateRange: { from: Date; to: Date }): Promise<TrainerSession[]>;
  update(id: string, data: Partial<TrainerSession>): Promise<TrainerSession>;
  getPerformanceData(trainerId: string, period: { from: Date; to: Date }): Promise<TrainerSession[]>;
}

// ============================================================
// Implementation
// ============================================================

export class TrainerService implements ITrainerService {
  constructor(
    private trainerRepository: ITrainerRepository,
    private sessionRepository: ITrainerSessionRepository,
  ) {}

  async createTrainer(data: CreateTrainerInput): Promise<Trainer> {
    const existingTrainer = await this.trainerRepository.findByEmail(data.email);
    if (existingTrainer) {
      throw new Error('Trainer with this email already exists');
    }

    const trainer: Trainer = {
      id: `TRN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name: data.name,
      email: data.email,
      phone: data.phone,
      specializations: data.specializations,
      certifications: data.certifications,
      bio: data.bio,
      profilePhoto: null,
      hourlyRate: data.hourlyRate,
      availability: data.availability,
      status: 'active',
      rating: 0,
      reviewCount: 0,
      hireDate: new Date(),
    };

    return this.trainerRepository.save(trainer);
  }

  async getTrainer(id: string): Promise<Trainer | null> {
    return this.trainerRepository.findById(id);
  }

  async getAllTrainers(filter?: TrainerFilterOptions): Promise<Trainer[]> {
    return this.trainerRepository.findAll(filter);
  }

  async updateTrainer(id: string, data: Partial<CreateTrainerInput>): Promise<Trainer> {
    const trainer = await this.trainerRepository.findById(id);
    if (!trainer) {
      throw new Error('Trainer not found');
    }
    return this.trainerRepository.update(id, data as Partial<Trainer>);
  }

  async getAvailableTrainers(date: Date, specialization?: Specialization): Promise<Trainer[]> {
    const allTrainers = await this.trainerRepository.findAll({
      status: 'active',
      specialization,
      availableOn: date,
    });

    const dayName = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][
      date.getDay()
    ] as keyof WeeklyAvailability;

    return allTrainers.filter((trainer) => {
      const daySlots = trainer.availability[dayName];
      return daySlots && daySlots.length > 0;
    });
  }

  async getTrainerSchedule(trainerId: string, weekStart: Date): Promise<TrainerSession[]> {
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekEnd.getDate() + 7);

    return this.sessionRepository.findByTrainer(trainerId, { from: weekStart, to: weekEnd });
  }

  async bookSession(
    memberId: string,
    trainerId: string,
    start: Date,
    end: Date,
    type: SessionType,
  ): Promise<TrainerSession> {
    const trainer = await this.trainerRepository.findById(trainerId);
    if (!trainer) {
      throw new Error('Trainer not found');
    }

    if (trainer.status !== 'active') {
      throw new Error('Trainer is not available');
    }

    const existingSessions = await this.sessionRepository.findByTrainer(trainerId, {
      from: start,
      to: end,
    });

    const conflict = existingSessions.find(
      (s) =>
        s.status !== 'cancelled' &&
        s.scheduledStart < end &&
        s.scheduledEnd > start,
    );

    if (conflict) {
      throw new Error('Trainer is not available at this time');
    }

    const session: TrainerSession = {
      id: `SES-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      trainerId,
      memberId,
      scheduledStart: start,
      scheduledEnd: end,
      status: 'scheduled',
      sessionType: type,
      notes: null,
      memberFeedback: null,
      memberRating: null,
      createdAt: new Date(),
    };

    return this.sessionRepository.save(session);
  }

  async cancelSession(sessionId: string, _reason?: string): Promise<TrainerSession> {
    const session = await this.sessionRepository.findById(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    if (session.status === 'completed') {
      throw new Error('Cannot cancel a completed session');
    }

    return this.sessionRepository.update(sessionId, { status: 'cancelled' });
  }

  async completeSession(sessionId: string, notes?: string): Promise<TrainerSession> {
    const session = await this.sessionRepository.findById(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    return this.sessionRepository.update(sessionId, {
      status: 'completed',
      notes: notes || session.notes,
    });
  }

  async addSessionFeedback(sessionId: string, rating: number, feedback: string): Promise<TrainerSession> {
    const session = await this.sessionRepository.findById(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    if (session.status !== 'completed') {
      throw new Error('Can only add feedback to completed sessions');
    }

    const updatedSession = await this.sessionRepository.update(sessionId, {
      memberRating: rating,
      memberFeedback: feedback,
    });

    const trainer = await this.trainerRepository.findById(session.trainerId);
    if (trainer) {
      const newReviewCount = trainer.reviewCount + 1;
      const newRating = (trainer.rating * trainer.reviewCount + rating) / newReviewCount;
      await this.trainerRepository.update(trainer.id, {
        rating: newRating,
        reviewCount: newReviewCount,
      });
    }

    return updatedSession;
  }

  async getTrainerPerformance(
    trainerId: string,
    period: { from: Date; to: Date },
  ): Promise<TrainerPerformanceMetrics> {
    const sessions = await this.sessionRepository.getPerformanceData(trainerId, period);
    const trainer = await this.trainerRepository.findById(trainerId);

    const completedSessions = sessions.filter((s) => s.status === 'completed');
    const cancelledSessions = sessions.filter((s) => s.status === 'cancelled');
    const noShowSessions = sessions.filter((s) => s.status === 'no-show');

    const totalRevenue = completedSessions.length * (trainer?.hourlyRate || 0);
    const ratedSessions = completedSessions.filter((s) => s.memberRating !== null);
    const averageRating =
      ratedSessions.length > 0
        ? ratedSessions.reduce((sum, s) => sum + (s.memberRating || 0), 0) / ratedSessions.length
        : 0;

    return {
      trainerId,
      totalSessions: sessions.length,
      completedSessions: completedSessions.length,
      cancelledSessions: cancelledSessions.length,
      noShowSessions: noShowSessions.length,
      averageRating,
      totalRevenue,
      clientRetentionRate: 0.75,
      period,
    };
  }

  async assignToClass(_trainerId: string, _classId: string): Promise<void> {
    // Implementation for assigning trainer to a class
  }
}

export function createTrainerService(
  trainerRepository: ITrainerRepository,
  sessionRepository: ITrainerSessionRepository,
): ITrainerService {
  return new TrainerService(trainerRepository, sessionRepository);
}
