/**
 * EquipmentService
 * 設備・機器管理
 *
 * @generated by MUSUBIX from C4 design
 * @module equipment-service
 * @designElement DES-GYM-005
 * @traces REQ-GYM-012, REQ-GYM-013, REQ-GYM-014
 */

// ============================================================
// Types & Interfaces
// ============================================================

export interface Equipment {
  id: string;
  name: string;
  category: EquipmentCategory;
  manufacturer: string;
  model: string;
  serialNumber: string;
  purchaseDate: Date;
  warrantyExpiry: Date | null;
  status: EquipmentStatus;
  location: string;
  lastMaintenanceDate: Date | null;
  nextMaintenanceDate: Date | null;
  usageCount: number;
  maxDailyUsage: number;
  notes: string | null;
}

export type EquipmentCategory =
  | 'cardio'
  | 'strength'
  | 'free-weights'
  | 'machines'
  | 'functional'
  | 'recovery'
  | 'accessories';

export type EquipmentStatus =
  | 'available'
  | 'in-use'
  | 'maintenance'
  | 'out-of-order'
  | 'retired';

export interface MaintenanceRecord {
  id: string;
  equipmentId: string;
  type: MaintenanceType;
  description: string;
  performedBy: string;
  performedAt: Date;
  cost: number;
  nextScheduledDate: Date | null;
  partsReplaced: string[];
  notes: string | null;
}

export type MaintenanceType = 'routine' | 'repair' | 'inspection' | 'cleaning' | 'calibration';

export interface EquipmentUsageLog {
  id: string;
  equipmentId: string;
  memberId: string;
  startTime: Date;
  endTime: Date | null;
  duration: number;
}

export interface CreateEquipmentInput {
  name: string;
  category: EquipmentCategory;
  manufacturer: string;
  model: string;
  serialNumber: string;
  purchaseDate: Date;
  warrantyExpiry?: Date;
  location: string;
  maxDailyUsage: number;
}

export interface EquipmentFilterOptions {
  category?: EquipmentCategory;
  status?: EquipmentStatus;
  location?: string;
  needsMaintenance?: boolean;
}

export interface EquipmentUtilizationReport {
  equipmentId: string;
  equipmentName: string;
  totalUsageHours: number;
  averageDailyUsage: number;
  peakUsageTimes: string[];
  utilizationRate: number;
  maintenanceCost: number;
  period: { from: Date; to: Date };
}

/**
 * EquipmentService interface
 * @implements REQ-GYM-012, REQ-GYM-013, REQ-GYM-014
 */
export interface IEquipmentService {
  createEquipment(data: CreateEquipmentInput): Promise<Equipment>;
  getEquipment(id: string): Promise<Equipment | null>;
  getAllEquipment(filter?: EquipmentFilterOptions): Promise<Equipment[]>;
  updateEquipment(id: string, data: Partial<CreateEquipmentInput>): Promise<Equipment>;
  setStatus(id: string, status: EquipmentStatus, reason?: string): Promise<Equipment>;
  getAvailableEquipment(category?: EquipmentCategory): Promise<Equipment[]>;
  startUsage(equipmentId: string, memberId: string): Promise<EquipmentUsageLog>;
  endUsage(usageLogId: string): Promise<EquipmentUsageLog>;
  scheduleMaintenance(equipmentId: string, date: Date, type: MaintenanceType): Promise<MaintenanceRecord>;
  recordMaintenance(equipmentId: string, record: Omit<MaintenanceRecord, 'id' | 'equipmentId'>): Promise<MaintenanceRecord>;
  getMaintenanceHistory(equipmentId: string): Promise<MaintenanceRecord[]>;
  getEquipmentDueForMaintenance(): Promise<Equipment[]>;
  getUtilizationReport(equipmentId: string, period: { from: Date; to: Date }): Promise<EquipmentUtilizationReport>;
  reportIssue(equipmentId: string, description: string, reportedBy: string): Promise<void>;
}

export interface IEquipmentRepository {
  save(equipment: Equipment): Promise<Equipment>;
  findById(id: string): Promise<Equipment | null>;
  findBySerialNumber(serialNumber: string): Promise<Equipment | null>;
  findAll(filter?: EquipmentFilterOptions): Promise<Equipment[]>;
  update(id: string, data: Partial<Equipment>): Promise<Equipment>;
  delete(id: string): Promise<boolean>;
}

export interface IMaintenanceRepository {
  save(record: MaintenanceRecord): Promise<MaintenanceRecord>;
  findByEquipment(equipmentId: string): Promise<MaintenanceRecord[]>;
  findUpcoming(days: number): Promise<MaintenanceRecord[]>;
}

export interface IUsageLogRepository {
  save(log: EquipmentUsageLog): Promise<EquipmentUsageLog>;
  findById(id: string): Promise<EquipmentUsageLog | null>;
  findActiveByEquipment(equipmentId: string): Promise<EquipmentUsageLog | null>;
  findByEquipment(equipmentId: string, period: { from: Date; to: Date }): Promise<EquipmentUsageLog[]>;
  update(id: string, data: Partial<EquipmentUsageLog>): Promise<EquipmentUsageLog>;
}

// ============================================================
// Implementation
// ============================================================

export class EquipmentService implements IEquipmentService {
  constructor(
    private equipmentRepository: IEquipmentRepository,
    private maintenanceRepository: IMaintenanceRepository,
    private usageLogRepository: IUsageLogRepository,
  ) {}

  async createEquipment(data: CreateEquipmentInput): Promise<Equipment> {
    const existingEquipment = await this.equipmentRepository.findBySerialNumber(data.serialNumber);
    if (existingEquipment) {
      throw new Error('Equipment with this serial number already exists');
    }

    const equipment: Equipment = {
      id: `EQ-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name: data.name,
      category: data.category,
      manufacturer: data.manufacturer,
      model: data.model,
      serialNumber: data.serialNumber,
      purchaseDate: data.purchaseDate,
      warrantyExpiry: data.warrantyExpiry || null,
      status: 'available',
      location: data.location,
      lastMaintenanceDate: null,
      nextMaintenanceDate: null,
      usageCount: 0,
      maxDailyUsage: data.maxDailyUsage,
      notes: null,
    };

    return this.equipmentRepository.save(equipment);
  }

  async getEquipment(id: string): Promise<Equipment | null> {
    return this.equipmentRepository.findById(id);
  }

  async getAllEquipment(filter?: EquipmentFilterOptions): Promise<Equipment[]> {
    return this.equipmentRepository.findAll(filter);
  }

  async updateEquipment(id: string, data: Partial<CreateEquipmentInput>): Promise<Equipment> {
    const equipment = await this.equipmentRepository.findById(id);
    if (!equipment) {
      throw new Error('Equipment not found');
    }
    return this.equipmentRepository.update(id, data as Partial<Equipment>);
  }

  async setStatus(id: string, status: EquipmentStatus, _reason?: string): Promise<Equipment> {
    const equipment = await this.equipmentRepository.findById(id);
    if (!equipment) {
      throw new Error('Equipment not found');
    }

    if (status === 'in-use') {
      const activeUsage = await this.usageLogRepository.findActiveByEquipment(id);
      if (!activeUsage) {
        throw new Error('Cannot set status to in-use without an active usage session');
      }
    }

    return this.equipmentRepository.update(id, { status });
  }

  async getAvailableEquipment(category?: EquipmentCategory): Promise<Equipment[]> {
    return this.equipmentRepository.findAll({
      status: 'available',
      category,
    });
  }

  async startUsage(equipmentId: string, memberId: string): Promise<EquipmentUsageLog> {
    const equipment = await this.equipmentRepository.findById(equipmentId);
    if (!equipment) {
      throw new Error('Equipment not found');
    }

    if (equipment.status !== 'available') {
      throw new Error(`Equipment is ${equipment.status}`);
    }

    const activeUsage = await this.usageLogRepository.findActiveByEquipment(equipmentId);
    if (activeUsage) {
      throw new Error('Equipment is already in use');
    }

    const usageLog: EquipmentUsageLog = {
      id: `USE-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      equipmentId,
      memberId,
      startTime: new Date(),
      endTime: null,
      duration: 0,
    };

    await this.equipmentRepository.update(equipmentId, {
      status: 'in-use',
      usageCount: equipment.usageCount + 1,
    });

    return this.usageLogRepository.save(usageLog);
  }

  async endUsage(usageLogId: string): Promise<EquipmentUsageLog> {
    const usageLog = await this.usageLogRepository.findById(usageLogId);
    if (!usageLog) {
      throw new Error('Usage log not found');
    }

    if (usageLog.endTime) {
      throw new Error('Usage already ended');
    }

    const endTime = new Date();
    const duration = Math.round((endTime.getTime() - usageLog.startTime.getTime()) / 60000);

    await this.equipmentRepository.update(usageLog.equipmentId, { status: 'available' });

    return this.usageLogRepository.update(usageLogId, {
      endTime,
      duration,
    });
  }

  async scheduleMaintenance(
    equipmentId: string,
    date: Date,
    type: MaintenanceType,
  ): Promise<MaintenanceRecord> {
    const equipment = await this.equipmentRepository.findById(equipmentId);
    if (!equipment) {
      throw new Error('Equipment not found');
    }

    await this.equipmentRepository.update(equipmentId, { nextMaintenanceDate: date });

    const record: MaintenanceRecord = {
      id: `MNT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      equipmentId,
      type,
      description: `Scheduled ${type} maintenance`,
      performedBy: '',
      performedAt: date,
      cost: 0,
      nextScheduledDate: null,
      partsReplaced: [],
      notes: 'Scheduled',
    };

    return this.maintenanceRepository.save(record);
  }

  async recordMaintenance(
    equipmentId: string,
    recordData: Omit<MaintenanceRecord, 'id' | 'equipmentId'>,
  ): Promise<MaintenanceRecord> {
    const equipment = await this.equipmentRepository.findById(equipmentId);
    if (!equipment) {
      throw new Error('Equipment not found');
    }

    const record: MaintenanceRecord = {
      id: `MNT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      equipmentId,
      ...recordData,
    };

    await this.equipmentRepository.update(equipmentId, {
      lastMaintenanceDate: recordData.performedAt,
      nextMaintenanceDate: recordData.nextScheduledDate,
      status: 'available',
    });

    return this.maintenanceRepository.save(record);
  }

  async getMaintenanceHistory(equipmentId: string): Promise<MaintenanceRecord[]> {
    return this.maintenanceRepository.findByEquipment(equipmentId);
  }

  async getEquipmentDueForMaintenance(): Promise<Equipment[]> {
    const allEquipment = await this.equipmentRepository.findAll({ needsMaintenance: true });
    const now = new Date();

    return allEquipment.filter(
      (eq) => eq.nextMaintenanceDate && eq.nextMaintenanceDate <= now,
    );
  }

  async getUtilizationReport(
    equipmentId: string,
    period: { from: Date; to: Date },
  ): Promise<EquipmentUtilizationReport> {
    const equipment = await this.equipmentRepository.findById(equipmentId);
    if (!equipment) {
      throw new Error('Equipment not found');
    }

    const usageLogs = await this.usageLogRepository.findByEquipment(equipmentId, period);
    const maintenanceRecords = await this.maintenanceRepository.findByEquipment(equipmentId);

    const totalUsageMinutes = usageLogs.reduce((sum, log) => sum + log.duration, 0);
    const totalUsageHours = totalUsageMinutes / 60;

    const daysDiff = Math.ceil(
      (period.to.getTime() - period.from.getTime()) / (1000 * 60 * 60 * 24),
    );
    const averageDailyUsage = totalUsageHours / daysDiff;

    const totalHoursInPeriod = daysDiff * 16;
    const utilizationRate = (totalUsageHours / totalHoursInPeriod) * 100;

    const maintenanceCost = maintenanceRecords
      .filter((r) => r.performedAt >= period.from && r.performedAt <= period.to)
      .reduce((sum, r) => sum + r.cost, 0);

    return {
      equipmentId,
      equipmentName: equipment.name,
      totalUsageHours,
      averageDailyUsage,
      peakUsageTimes: ['17:00-19:00', '07:00-09:00'],
      utilizationRate,
      maintenanceCost,
      period,
    };
  }

  async reportIssue(equipmentId: string, _description: string, _reportedBy: string): Promise<void> {
    await this.equipmentRepository.update(equipmentId, { status: 'out-of-order' });
  }
}

export function createEquipmentService(
  equipmentRepository: IEquipmentRepository,
  maintenanceRepository: IMaintenanceRepository,
  usageLogRepository: IUsageLogRepository,
): IEquipmentService {
  return new EquipmentService(equipmentRepository, maintenanceRepository, usageLogRepository);
}
